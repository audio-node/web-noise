{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,M,C,S,C,C,C,C,C,ECKK,IAAA,EAAA,EAAA,kD,E,iB,C,GAuEL,EAAA,MAAA,CAAA,EAAA,+BAAA,IAAa,G,I,E,E,mCArEb,EAAA,EAAA,2BACA,EAAA,EAAA,2BACA,EAAA,EAAA,0BAGA,IAAM,EAAe,KAAK,GAAG,CAAC,GAAM,CAAA,AADP,GACO,UAAa,GAG3C,EAAkB,CACtB,EACA,EACA,EACA,KAEA,IAAI,EAAwB,CAAc,CAAC,IAAI,CAE/C,IAAK,IAAI,EAAI,EAAG,EAAI,IAAK,GAAK,EAAG,KAI3B,EACA,EAJJ,IAAM,EAAa,AAAC,CAAA,EAAS,CAAA,EAAK,EAAY,MAAM,CAC9C,EAAgB,KAAK,GAAG,CAAC,CAAW,CAAC,EAAW,EAKtD,GAAI,AAAwB,OAAxB,EAA8B,CAChC,KACE,EAAoB,IAAI,CAAG,GAC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","sources":["<anon>","packages/base-nodes/src/Limiter/worklet/index.ts","node_modules/.pnpm/@swc+helpers@0.5.8/node_modules/@swc/helpers/esm/_define_property.js","node_modules/.pnpm/@parcel+transformer-js@2.12.0_@parcel+core@2.12.0/node_modules/@parcel/transformer-js/src/esmodule-helpers.js","packages/base-nodes/src/Limiter/worklet/constant-memory-deque.ts","packages/base-nodes/src/Limiter/worklet/read-from-ring-buffer.ts","packages/base-nodes/src/Limiter/worklet/write-to-ring-buffer.ts"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"iIcye\":[function(require,module,exports) {\n/*\n * original source is taken from https://github.com/chrisguttandin/limiter-audio-worklet-processor\n * had to be modified to achieve needed threshold\n *\n * @TODO: parametrise threshold and release\n * */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"LimiterAudioWorkletProcessor\", ()=>LimiterAudioWorkletProcessor);\nvar _defineProperty = require(\"@swc/helpers/_/_define_property\");\nvar _constantMemoryDeque = require(\"./constant-memory-deque\");\nvar _readFromRingBuffer = require(\"./read-from-ring-buffer\");\nvar _writeToRingBuffer = require(\"./write-to-ring-buffer\");\nconst RELEASE_TIME_SECONDS = 0.5;\nconst RELEASE_GAIN = Math.exp(-1 / (sampleRate * RELEASE_TIME_SECONDS));\nconst THRESHOLD = 1;\nconst computeEnvelope = (envelopeBuffer, delayBuffer, offset, constantMemoryDeque)=>{\n    let previousEnvelopeValue = envelopeBuffer[127];\n    for(let i = 0; i < 128; i += 1){\n        const readOffset = (offset + i) % delayBuffer.length;\n        const absoluteValue = Math.abs(delayBuffer[readOffset]);\n        let maximumValue;\n        let remainingSteps;\n        if (constantMemoryDeque !== null) {\n            while(constantMemoryDeque.size > 0 && absoluteValue >= Math.abs(delayBuffer[constantMemoryDeque.first()]))constantMemoryDeque.shift();\n            if (constantMemoryDeque.size === 0 || absoluteValue < Math.abs(delayBuffer[constantMemoryDeque.first()])) constantMemoryDeque.unshift(readOffset);\n            const dropOffset = (offset + i + 128) % delayBuffer.length;\n            if (constantMemoryDeque.last() === dropOffset) constantMemoryDeque.pop();\n            const indexOfMaximum = constantMemoryDeque.last();\n            maximumValue = Math.abs(delayBuffer[indexOfMaximum]);\n            remainingSteps = indexOfMaximum < readOffset ? readOffset - indexOfMaximum + 1 : readOffset + delayBuffer.length - indexOfMaximum + 1;\n        } else {\n            maximumValue = absoluteValue;\n            remainingSteps = 1;\n        }\n        const difference = previousEnvelopeValue - maximumValue;\n        if (previousEnvelopeValue < maximumValue) previousEnvelopeValue = previousEnvelopeValue - difference / remainingSteps;\n        else previousEnvelopeValue = maximumValue + RELEASE_GAIN * difference;\n        envelopeBuffer[i] = previousEnvelopeValue;\n    }\n};\nclass LimiterAudioWorkletProcessor extends AudioWorkletProcessor {\n    process([input], [output]) {\n        const numberOfChannels = input.length;\n        const writeOffset = this._writeOffset;\n        for(let channel = 0; channel < numberOfChannels; channel += 1){\n            const constantMemoryDeque = this._constantMemoryDeques === null ? null : this._constantMemoryDeques[channel];\n            const delayBuffer = this._delayBuffers[channel];\n            const envelopeBuffer = this._envelopeBuffers[channel];\n            const inputChannelData = input[channel];\n            const outputChannelData = output[channel];\n            this._writeOffset = (0, _writeToRingBuffer.writeToRingBuffer)(delayBuffer, inputChannelData, writeOffset);\n            computeEnvelope(envelopeBuffer, delayBuffer, writeOffset, constantMemoryDeque);\n            (0, _readFromRingBuffer.readFromRingBuffer)(delayBuffer, outputChannelData, this._writeOffset);\n            for(let i = 0; i < 128; i += 1){\n                const gain = Math.min(1, THRESHOLD / envelopeBuffer[i]);\n                outputChannelData[i] *= gain;\n            }\n        }\n        return true;\n    }\n    constructor({ channelCount, channelCountMode, numberOfInputs, numberOfOutputs, outputChannelCount, processorOptions }){\n        const attack = typeof processorOptions === \"object\" && processorOptions !== null && \"attack\" in processorOptions ? processorOptions.attack : 0;\n        if (typeof attack !== \"number\") throw new Error('The attack needs to be of type \"number\".');\n        if (attack < 0) throw new Error(\"The attack can't be negative.\");\n        if (channelCountMode !== \"explicit\") throw new Error('The channelCountMode needs to be \"explicit\".');\n        if (numberOfInputs !== 1) throw new Error(\"The numberOfInputs must be 1.\");\n        if (numberOfOutputs !== 1) throw new Error(\"The numberOfOutputs must be 1.\");\n        if (outputChannelCount === undefined || channelCount !== outputChannelCount[0]) throw new Error(\"The channelCount must be the same as the outputChannelCount of the first output.\");\n        super();\n        (0, _defineProperty._)(this, \"_constantMemoryDeques\", void 0);\n        (0, _defineProperty._)(this, \"_delayBuffers\", void 0);\n        (0, _defineProperty._)(this, \"_envelopeBuffers\", void 0);\n        (0, _defineProperty._)(this, \"_writeOffset\", void 0);\n        const attackSamples = sampleRate * attack;\n        const delaySize = Math.round(attackSamples);\n        const delayBufferSize = delaySize + 128;\n        this._constantMemoryDeques = delaySize === 0 ? null : Array.from({\n            length: channelCount\n        }, ()=>new (0, _constantMemoryDeque.ConstantMemoryDeque)(new Uint16Array(delaySize + 1)));\n        this._delayBuffers = Array.from({\n            length: channelCount\n        }, ()=>new Float32Array(delayBufferSize));\n        this._envelopeBuffers = Array.from({\n            length: channelCount\n        }, ()=>new Float32Array(128));\n        this._writeOffset = 0;\n    }\n}\n(0, _defineProperty._)(LimiterAudioWorkletProcessor, \"parameterDescriptors\", []);\ntry {\n    //@ts-ignore\n    registerProcessor(\"limiter-processor\", LimiterAudioWorkletProcessor);\n} catch (e) {}\n\n},{\"@swc/helpers/_/_define_property\":\"ktYkZ\",\"./constant-memory-deque\":\"6wWFN\",\"./read-from-ring-buffer\":\"dXBr0\",\"./write-to-ring-buffer\":\"3hS4Y\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5zHCx\"}],\"ktYkZ\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"_define_property\", ()=>_define_property);\nparcelHelpers.export(exports, \"_\", ()=>_define_property);\nfunction _define_property(obj, key, value) {\n    if (key in obj) Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    });\n    else obj[key] = value;\n    return obj;\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5zHCx\"}],\"5zHCx\":[function(require,module,exports) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, \"__esModule\", {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\" || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"6wWFN\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"ConstantMemoryDeque\", ()=>ConstantMemoryDeque);\nvar _defineProperty = require(\"@swc/helpers/_/_define_property\");\nclass ConstantMemoryDeque {\n    get size() {\n        return this._isEmpty ? 0 : this._lastIndex < this._firstIndex ? this._buffer.length - this._firstIndex + this._lastIndex + 1 : this._lastIndex - this._firstIndex + 1;\n    }\n    first() {\n        this._throwIfEmpty();\n        return this._buffer[this._firstIndex];\n    }\n    last() {\n        this._throwIfEmpty();\n        return this._buffer[this._lastIndex];\n    }\n    pop() {\n        this._throwIfEmpty();\n        if (this._firstIndex === this._lastIndex) this._isEmpty = true;\n        else this._lastIndex = this._decrementIndex(this._lastIndex);\n    }\n    shift() {\n        this._throwIfEmpty();\n        if (this._firstIndex === this._lastIndex) this._isEmpty = true;\n        else this._firstIndex = this._incrementIndex(this._firstIndex);\n    }\n    unshift(value) {\n        if (this._isEmpty) {\n            this._buffer[this._firstIndex] = value;\n            this._isEmpty = false;\n        } else {\n            const nextIndex = this._decrementIndex(this._firstIndex);\n            if (nextIndex === this._lastIndex) throw new Error(\"Deque is full.\");\n            this._buffer[nextIndex] = value;\n            this._firstIndex = nextIndex;\n        }\n    }\n    _decrementIndex(index) {\n        return index === 0 ? this._buffer.length - 1 : index - 1;\n    }\n    _incrementIndex(index) {\n        return (index + 1) % this._buffer.length;\n    }\n    _throwIfEmpty() {\n        if (this._isEmpty) throw new Error(\"Deque is empty.\");\n    }\n    constructor(_buffer){\n        (0, _defineProperty._)(this, \"_buffer\", void 0);\n        (0, _defineProperty._)(this, \"_firstIndex\", void 0);\n        (0, _defineProperty._)(this, \"_isEmpty\", void 0);\n        (0, _defineProperty._)(this, \"_lastIndex\", void 0);\n        this._buffer = _buffer;\n        this._firstIndex = 0;\n        this._isEmpty = true;\n        this._lastIndex = 0;\n        if (this._buffer.length === 0) throw new Error(\"The given buffer is too small.\");\n    }\n}\n\n},{\"@swc/helpers/_/_define_property\":\"ktYkZ\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5zHCx\"}],\"dXBr0\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"readFromRingBuffer\", ()=>readFromRingBuffer);\nconst readFromRingBuffer = (target, source, offset)=>{\n    const theoreticalNextOffset = offset + source.length;\n    if (theoreticalNextOffset <= target.length) {\n        source.set(new Float32Array(target.buffer, target.byteOffset + offset * source.BYTES_PER_ELEMENT, source.length));\n        return theoreticalNextOffset === target.length ? 0 : theoreticalNextOffset;\n    }\n    const nextOffset = theoreticalNextOffset - target.length;\n    const lengthOfFirstChunk = target.length - offset;\n    source.set(new Float32Array(target.buffer, target.byteOffset + offset * source.BYTES_PER_ELEMENT, lengthOfFirstChunk));\n    source.set(new Float32Array(target.buffer, target.byteOffset, nextOffset), lengthOfFirstChunk);\n    return nextOffset;\n};\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5zHCx\"}],\"3hS4Y\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"writeToRingBuffer\", ()=>writeToRingBuffer);\nconst writeToRingBuffer = (target, source, offset)=>{\n    const theoreticalNextOffset = offset + source.length;\n    if (theoreticalNextOffset <= target.length) {\n        target.set(source, offset);\n        return theoreticalNextOffset === target.length ? 0 : theoreticalNextOffset;\n    }\n    const nextOffset = theoreticalNextOffset - target.length;\n    const lengthOfFirstChunk = target.length - offset;\n    target.set(new Float32Array(source.buffer, source.byteOffset, lengthOfFirstChunk), offset);\n    target.set(new Float32Array(source.buffer, source.byteOffset + lengthOfFirstChunk * source.BYTES_PER_ELEMENT, nextOffset));\n    return nextOffset;\n};\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"5zHCx\"}]},[\"iIcye\"], \"iIcye\", \"parcelRequirec6d8\")\n\n//# sourceMappingURL=worklet.7ea47eda.js.map\n","/* \n * original source is taken from https://github.com/chrisguttandin/limiter-audio-worklet-processor\n * had to be modified to achieve needed threshold\n * \n * @TODO: parametrise threshold and release\n * */\n\nimport { ConstantMemoryDeque } from \"./constant-memory-deque\";\nimport { readFromRingBuffer } from \"./read-from-ring-buffer\";\nimport { writeToRingBuffer } from \"./write-to-ring-buffer\";\n\nconst RELEASE_TIME_SECONDS = 0.5;\nconst RELEASE_GAIN = Math.exp(-1 / (sampleRate * RELEASE_TIME_SECONDS));\nconst THRESHOLD = 1;\n\nconst computeEnvelope = (\n  envelopeBuffer: Float32Array,\n  delayBuffer: Float32Array,\n  offset: number,\n  constantMemoryDeque: null | ConstantMemoryDeque,\n): void => {\n  let previousEnvelopeValue = envelopeBuffer[127];\n\n  for (let i = 0; i < 128; i += 1) {\n    const readOffset = (offset + i) % delayBuffer.length;\n    const absoluteValue = Math.abs(delayBuffer[readOffset]);\n\n    let maximumValue: number;\n    let remainingSteps: number;\n\n    if (constantMemoryDeque !== null) {\n      while (\n        constantMemoryDeque.size > 0 &&\n        absoluteValue >= Math.abs(delayBuffer[constantMemoryDeque.first()])\n      ) {\n        constantMemoryDeque.shift();\n      }\n\n      if (\n        constantMemoryDeque.size === 0 ||\n        absoluteValue < Math.abs(delayBuffer[constantMemoryDeque.first()])\n      ) {\n        constantMemoryDeque.unshift(readOffset);\n      }\n\n      const dropOffset = (offset + i + 128) % delayBuffer.length;\n\n      if (constantMemoryDeque.last() === dropOffset) {\n        constantMemoryDeque.pop();\n      }\n\n      const indexOfMaximum = constantMemoryDeque.last();\n\n      maximumValue = Math.abs(delayBuffer[indexOfMaximum]);\n      remainingSteps =\n        indexOfMaximum < readOffset\n          ? readOffset - indexOfMaximum + 1\n          : readOffset + delayBuffer.length - indexOfMaximum + 1;\n    } else {\n      maximumValue = absoluteValue;\n      remainingSteps = 1;\n    }\n\n    const difference = previousEnvelopeValue - maximumValue;\n\n    if (previousEnvelopeValue < maximumValue) {\n      previousEnvelopeValue =\n        previousEnvelopeValue - difference / remainingSteps;\n    } else {\n      previousEnvelopeValue = maximumValue + RELEASE_GAIN * difference;\n    }\n\n    envelopeBuffer[i] = previousEnvelopeValue;\n  }\n};\n\nexport class LimiterAudioWorkletProcessor extends AudioWorkletProcessor {\n  static parameterDescriptors = [];\n\n  _constantMemoryDeques: null | ConstantMemoryDeque[];\n  _delayBuffers: Float32Array[];\n  _envelopeBuffers: Float32Array[];\n  _writeOffset: number;\n\n  constructor({\n    channelCount,\n    channelCountMode,\n    numberOfInputs,\n    numberOfOutputs,\n    outputChannelCount,\n    processorOptions,\n  }: AudioWorkletNodeOptions) {\n    const attack =\n      typeof processorOptions === \"object\" &&\n      processorOptions !== null &&\n      \"attack\" in processorOptions\n        ? processorOptions.attack\n        : 0;\n\n    if (typeof attack !== \"number\") {\n      throw new Error('The attack needs to be of type \"number\".');\n    }\n\n    if (attack < 0) {\n      throw new Error(\"The attack can't be negative.\");\n    }\n\n    if (channelCountMode !== \"explicit\") {\n      throw new Error('The channelCountMode needs to be \"explicit\".');\n    }\n\n    if (numberOfInputs !== 1) {\n      throw new Error(\"The numberOfInputs must be 1.\");\n    }\n\n    if (numberOfOutputs !== 1) {\n      throw new Error(\"The numberOfOutputs must be 1.\");\n    }\n\n    if (\n      outputChannelCount === undefined ||\n      channelCount !== outputChannelCount[0]\n    ) {\n      throw new Error(\n        \"The channelCount must be the same as the outputChannelCount of the first output.\",\n      );\n    }\n\n    super();\n\n    const attackSamples = sampleRate * attack;\n    const delaySize = Math.round(attackSamples);\n    const delayBufferSize = delaySize + 128;\n\n    this._constantMemoryDeques =\n      delaySize === 0\n        ? null\n        : Array.from(\n            { length: channelCount },\n            () => new ConstantMemoryDeque(new Uint16Array(delaySize + 1)),\n          );\n    this._delayBuffers = Array.from(\n      { length: channelCount },\n      () => new Float32Array(delayBufferSize),\n    );\n    this._envelopeBuffers = Array.from(\n      { length: channelCount },\n      () => new Float32Array(128),\n    );\n    this._writeOffset = 0;\n  }\n\n  process([input]: Float32Array[][], [output]: Float32Array[][]) {\n    const numberOfChannels = input.length;\n    const writeOffset = this._writeOffset;\n\n    for (let channel = 0; channel < numberOfChannels; channel += 1) {\n      const constantMemoryDeque =\n        this._constantMemoryDeques === null\n          ? null\n          : this._constantMemoryDeques[channel];\n      const delayBuffer = this._delayBuffers[channel];\n      const envelopeBuffer = this._envelopeBuffers[channel];\n      const inputChannelData = input[channel];\n      const outputChannelData = output[channel];\n\n      this._writeOffset = writeToRingBuffer(\n        delayBuffer,\n        inputChannelData,\n        writeOffset,\n      );\n\n      computeEnvelope(\n        envelopeBuffer,\n        delayBuffer,\n        writeOffset,\n        constantMemoryDeque,\n      );\n\n      readFromRingBuffer(delayBuffer, outputChannelData, this._writeOffset);\n\n      for (let i = 0; i < 128; i += 1) {\n        const gain = Math.min(1, THRESHOLD / envelopeBuffer[i]);\n\n        outputChannelData[i] *= gain;\n      }\n    }\n\n    return true;\n  }\n}\n\ntry {\n  //@ts-ignore\n  registerProcessor(\"limiter-processor\", LimiterAudioWorkletProcessor);\n} catch (e) {}\n","export function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n    } else obj[key] = value;\n\n    return obj;\n}\nexport { _define_property as _ };\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","export class ConstantMemoryDeque {\n    private _firstIndex: number;\n\n    private _isEmpty: boolean;\n\n    private _lastIndex: number;\n\n    constructor(private _buffer: Uint16Array) {\n        this._firstIndex = 0;\n        this._isEmpty = true;\n        this._lastIndex = 0;\n\n        if (this._buffer.length === 0) {\n            throw new Error('The given buffer is too small.');\n        }\n    }\n\n    get size(): number {\n        return this._isEmpty\n            ? 0\n            : this._lastIndex < this._firstIndex\n            ? this._buffer.length - this._firstIndex + this._lastIndex + 1\n            : this._lastIndex - this._firstIndex + 1;\n    }\n\n    public first(): number {\n        this._throwIfEmpty();\n\n        return this._buffer[this._firstIndex];\n    }\n\n    public last(): number {\n        this._throwIfEmpty();\n\n        return this._buffer[this._lastIndex];\n    }\n\n    public pop(): void {\n        this._throwIfEmpty();\n\n        if (this._firstIndex === this._lastIndex) {\n            this._isEmpty = true;\n        } else {\n            this._lastIndex = this._decrementIndex(this._lastIndex);\n        }\n    }\n\n    public shift(): void {\n        this._throwIfEmpty();\n\n        if (this._firstIndex === this._lastIndex) {\n            this._isEmpty = true;\n        } else {\n            this._firstIndex = this._incrementIndex(this._firstIndex);\n        }\n    }\n\n    public unshift(value: number): void {\n        if (this._isEmpty) {\n            this._buffer[this._firstIndex] = value;\n            this._isEmpty = false;\n        } else {\n            const nextIndex = this._decrementIndex(this._firstIndex);\n\n            if (nextIndex === this._lastIndex) {\n                throw new Error('Deque is full.');\n            }\n\n            this._buffer[nextIndex] = value;\n            this._firstIndex = nextIndex;\n        }\n    }\n\n    private _decrementIndex(index: number): number {\n        return index === 0 ? this._buffer.length - 1 : index - 1;\n    }\n\n    private _incrementIndex(index: number): number {\n        return (index + 1) % this._buffer.length;\n    }\n\n    private _throwIfEmpty(): void {\n        if (this._isEmpty) {\n            throw new Error('Deque is empty.');\n        }\n    }\n}\n","export const readFromRingBuffer = (target: Float32Array, source: Float32Array, offset: number): number => {\n    const theoreticalNextOffset = offset + source.length;\n    if (theoreticalNextOffset <= target.length) {\n        source.set(new Float32Array(target.buffer, target.byteOffset + offset * source.BYTES_PER_ELEMENT, source.length));\n\n        return theoreticalNextOffset === target.length ? 0 : theoreticalNextOffset;\n    }\n\n    const nextOffset = theoreticalNextOffset - target.length;\n    const lengthOfFirstChunk = target.length - offset;\n\n    source.set(new Float32Array(target.buffer, target.byteOffset + offset * source.BYTES_PER_ELEMENT, lengthOfFirstChunk));\n    source.set(new Float32Array(target.buffer, target.byteOffset, nextOffset), lengthOfFirstChunk);\n\n    return nextOffset;\n};\n","export const writeToRingBuffer = (target: Float32Array, source: Float32Array, offset: number): number => {\n    const theoreticalNextOffset = offset + source.length;\n    if (theoreticalNextOffset <= target.length) {\n        target.set(source, offset);\n\n        return theoreticalNextOffset === target.length ? 0 : theoreticalNextOffset;\n    }\n\n    const nextOffset = theoreticalNextOffset - target.length;\n    const lengthOfFirstChunk = target.length - offset;\n\n    target.set(new Float32Array(source.buffer, source.byteOffset, lengthOfFirstChunk), offset);\n    target.set(new Float32Array(source.buffer, source.byteOffset + lengthOfFirstChunk * source.BYTES_PER_ELEMENT, nextOffset));\n\n    return nextOffset;\n};\n"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","parcelHelpers","defineInteropFlag","export","LimiterAudioWorkletProcessor","_defineProperty","_constantMemoryDeque","_readFromRingBuffer","_writeToRingBuffer","RELEASE_GAIN","Math","exp","sampleRate","computeEnvelope","envelopeBuffer","delayBuffer","offset","constantMemoryDeque","previousEnvelopeValue","maximumValue","remainingSteps","readOffset","absoluteValue","abs","size","first","shift","unshift","dropOffset","last","pop","indexOfMaximum","difference","AudioWorkletProcessor","process","input","output","numberOfChannels","writeOffset","_writeOffset","channel","_constantMemoryDeques","_delayBuffers","_envelopeBuffers","inputChannelData","outputChannelData","writeToRingBuffer","readFromRingBuffer","gain","min","THRESHOLD","constructor","channelCount","channelCountMode","numberOfInputs","numberOfOutputs","outputChannelCount","processorOptions","attack","undefined","_","delaySize","round","delayBufferSize","Array","from","ConstantMemoryDeque","Uint16Array","Float32Array","registerProcessor","e","_define_property","obj","key","value","enumerable","configurable","writable","interopDefault","a","__esModule","default","exportAll","source","dest","keys","forEach","prototype","hasOwnProperty","destName","_isEmpty","_lastIndex","_firstIndex","_buffer","_throwIfEmpty","_decrementIndex","_incrementIndex","nextIndex","index","target","theoreticalNextOffset","set","buffer","byteOffset","BYTES_PER_ELEMENT","nextOffset","lengthOfFirstChunk"],"version":3,"file":"worklet.7ea47eda.js.map"}