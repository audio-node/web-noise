{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,M,C,S,C,C,C,C,C,GCAC,AAAW,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,EAAJ,KAAA,EAA0C,GAAG,CAAC,GAAG,EAAE,OAAO,EAAE,EAAE,CAAC,GAAG,GAAG,EAAE,OAAO,EAAE,EAAE,CAAC,GAAG,IAAI,EAAE,AAAI,MAAM,uBAAuB,EAAE,IAAK,OAAM,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,SAAS,CAAC,EAAmB,O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","sources":["<anon>","node_modules/.pnpm/github.com+olvb+phaze@841f37b822c955868075072a6abe8bfad782432e/node_modules/phaze-vocoder/www/phase-vocoder.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"jWRiz\":[function(require,module,exports) {\n(function() {\n    function r(e, n, t) {\n        function o(i, f) {\n            if (!n[i]) {\n                if (!e[i]) {\n                    var c = undefined;\n                    if (!f && c) return c(i, !0);\n                    if (u) return u(i, !0);\n                    var a = new Error(\"Cannot find module '\" + i + \"'\");\n                    throw a.code = \"MODULE_NOT_FOUND\", a;\n                }\n                var p = n[i] = {\n                    exports: {}\n                };\n                e[i][0].call(p.exports, function(r) {\n                    var n = e[i][1][r];\n                    return o(n || r);\n                }, p, p.exports, r, e, n, t);\n            }\n            return n[i].exports;\n        }\n        for(var u = undefined, i = 0; i < t.length; i++)o(t[i]);\n        return o;\n    }\n    return r;\n})()({\n    1: [\n        function(require, module, exports) {\n            \"use strict\";\n            function FFT(size) {\n                this.size = size | 0;\n                if (this.size <= 1 || (this.size & this.size - 1) !== 0) throw new Error(\"FFT size must be a power of two and bigger than 1\");\n                this._csize = size << 1;\n                // NOTE: Use of `var` is intentional for old V8 versions\n                var table = new Array(this.size * 2);\n                for(var i = 0; i < table.length; i += 2){\n                    const angle = Math.PI * i / this.size;\n                    table[i] = Math.cos(angle);\n                    table[i + 1] = -Math.sin(angle);\n                }\n                this.table = table;\n                // Find size's power of two\n                var power = 0;\n                for(var t = 1; this.size > t; t <<= 1)power++;\n                // Calculate initial step's width:\n                //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n                //   * Otherwise it is the same as `power` to give len=4\n                this._width = power % 2 === 0 ? power - 1 : power;\n                // Pre-compute bit-reversal patterns\n                this._bitrev = new Array(1 << this._width);\n                for(var j = 0; j < this._bitrev.length; j++){\n                    this._bitrev[j] = 0;\n                    for(var shift = 0; shift < this._width; shift += 2){\n                        var revShift = this._width - shift - 2;\n                        this._bitrev[j] |= (j >>> shift & 3) << revShift;\n                    }\n                }\n                this._out = null;\n                this._data = null;\n                this._inv = 0;\n            }\n            module.exports = FFT;\n            FFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {\n                var res = storage || new Array(complex.length >>> 1);\n                for(var i = 0; i < complex.length; i += 2)res[i >>> 1] = complex[i];\n                return res;\n            };\n            FFT.prototype.createComplexArray = function createComplexArray() {\n                const res = new Array(this._csize);\n                for(var i = 0; i < res.length; i++)res[i] = 0;\n                return res;\n            };\n            FFT.prototype.toComplexArray = function toComplexArray(input, storage) {\n                var res = storage || this.createComplexArray();\n                for(var i = 0; i < res.length; i += 2){\n                    res[i] = input[i >>> 1];\n                    res[i + 1] = 0;\n                }\n                return res;\n            };\n            FFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {\n                var size = this._csize;\n                var half = size >>> 1;\n                for(var i = 2; i < half; i += 2){\n                    spectrum[size - i] = spectrum[i];\n                    spectrum[size - i + 1] = -spectrum[i + 1];\n                }\n            };\n            FFT.prototype.transform = function transform(out, data) {\n                if (out === data) throw new Error(\"Input and output buffers must be different\");\n                this._out = out;\n                this._data = data;\n                this._inv = 0;\n                this._transform4();\n                this._out = null;\n                this._data = null;\n            };\n            FFT.prototype.realTransform = function realTransform(out, data) {\n                if (out === data) throw new Error(\"Input and output buffers must be different\");\n                this._out = out;\n                this._data = data;\n                this._inv = 0;\n                this._realTransform4();\n                this._out = null;\n                this._data = null;\n            };\n            FFT.prototype.inverseTransform = function inverseTransform(out, data) {\n                if (out === data) throw new Error(\"Input and output buffers must be different\");\n                this._out = out;\n                this._data = data;\n                this._inv = 1;\n                this._transform4();\n                for(var i = 0; i < out.length; i++)out[i] /= this.size;\n                this._out = null;\n                this._data = null;\n            };\n            // radix-4 implementation\n            //\n            // NOTE: Uses of `var` are intentional for older V8 version that do not\n            // support both `let compound assignments` and `const phi`\n            FFT.prototype._transform4 = function _transform4() {\n                var out = this._out;\n                var size = this._csize;\n                // Initial step (permute and transform)\n                var width = this._width;\n                var step = 1 << width;\n                var len = size / step << 1;\n                var outOff;\n                var t;\n                var bitrev = this._bitrev;\n                if (len === 4) for(outOff = 0, t = 0; outOff < size; outOff += len, t++){\n                    const off = bitrev[t];\n                    this._singleTransform2(outOff, off, step);\n                }\n                else // len === 8\n                for(outOff = 0, t = 0; outOff < size; outOff += len, t++){\n                    const off = bitrev[t];\n                    this._singleTransform4(outOff, off, step);\n                }\n                // Loop through steps in decreasing order\n                var inv = this._inv ? -1 : 1;\n                var table = this.table;\n                for(step >>= 2; step >= 2; step >>= 2){\n                    len = size / step << 1;\n                    var quarterLen = len >>> 2;\n                    // Loop through offsets in the data\n                    for(outOff = 0; outOff < size; outOff += len){\n                        // Full case\n                        var limit = outOff + quarterLen;\n                        for(var i = outOff, k = 0; i < limit; i += 2, k += step){\n                            const A = i;\n                            const B = A + quarterLen;\n                            const C = B + quarterLen;\n                            const D = C + quarterLen;\n                            // Original values\n                            const Ar = out[A];\n                            const Ai = out[A + 1];\n                            const Br = out[B];\n                            const Bi = out[B + 1];\n                            const Cr = out[C];\n                            const Ci = out[C + 1];\n                            const Dr = out[D];\n                            const Di = out[D + 1];\n                            // Middle values\n                            const MAr = Ar;\n                            const MAi = Ai;\n                            const tableBr = table[k];\n                            const tableBi = inv * table[k + 1];\n                            const MBr = Br * tableBr - Bi * tableBi;\n                            const MBi = Br * tableBi + Bi * tableBr;\n                            const tableCr = table[2 * k];\n                            const tableCi = inv * table[2 * k + 1];\n                            const MCr = Cr * tableCr - Ci * tableCi;\n                            const MCi = Cr * tableCi + Ci * tableCr;\n                            const tableDr = table[3 * k];\n                            const tableDi = inv * table[3 * k + 1];\n                            const MDr = Dr * tableDr - Di * tableDi;\n                            const MDi = Dr * tableDi + Di * tableDr;\n                            // Pre-Final values\n                            const T0r = MAr + MCr;\n                            const T0i = MAi + MCi;\n                            const T1r = MAr - MCr;\n                            const T1i = MAi - MCi;\n                            const T2r = MBr + MDr;\n                            const T2i = MBi + MDi;\n                            const T3r = inv * (MBr - MDr);\n                            const T3i = inv * (MBi - MDi);\n                            // Final values\n                            const FAr = T0r + T2r;\n                            const FAi = T0i + T2i;\n                            const FCr = T0r - T2r;\n                            const FCi = T0i - T2i;\n                            const FBr = T1r + T3i;\n                            const FBi = T1i - T3r;\n                            const FDr = T1r - T3i;\n                            const FDi = T1i + T3r;\n                            out[A] = FAr;\n                            out[A + 1] = FAi;\n                            out[B] = FBr;\n                            out[B + 1] = FBi;\n                            out[C] = FCr;\n                            out[C + 1] = FCi;\n                            out[D] = FDr;\n                            out[D + 1] = FDi;\n                        }\n                    }\n                }\n            };\n            // radix-2 implementation\n            //\n            // NOTE: Only called for len=4\n            FFT.prototype._singleTransform2 = function _singleTransform2(outOff, off, step) {\n                const out = this._out;\n                const data = this._data;\n                const evenR = data[off];\n                const evenI = data[off + 1];\n                const oddR = data[off + step];\n                const oddI = data[off + step + 1];\n                const leftR = evenR + oddR;\n                const leftI = evenI + oddI;\n                const rightR = evenR - oddR;\n                const rightI = evenI - oddI;\n                out[outOff] = leftR;\n                out[outOff + 1] = leftI;\n                out[outOff + 2] = rightR;\n                out[outOff + 3] = rightI;\n            };\n            // radix-4\n            //\n            // NOTE: Only called for len=8\n            FFT.prototype._singleTransform4 = function _singleTransform4(outOff, off, step) {\n                const out = this._out;\n                const data = this._data;\n                const inv = this._inv ? -1 : 1;\n                const step2 = step * 2;\n                const step3 = step * 3;\n                // Original values\n                const Ar = data[off];\n                const Ai = data[off + 1];\n                const Br = data[off + step];\n                const Bi = data[off + step + 1];\n                const Cr = data[off + step2];\n                const Ci = data[off + step2 + 1];\n                const Dr = data[off + step3];\n                const Di = data[off + step3 + 1];\n                // Pre-Final values\n                const T0r = Ar + Cr;\n                const T0i = Ai + Ci;\n                const T1r = Ar - Cr;\n                const T1i = Ai - Ci;\n                const T2r = Br + Dr;\n                const T2i = Bi + Di;\n                const T3r = inv * (Br - Dr);\n                const T3i = inv * (Bi - Di);\n                // Final values\n                const FAr = T0r + T2r;\n                const FAi = T0i + T2i;\n                const FBr = T1r + T3i;\n                const FBi = T1i - T3r;\n                const FCr = T0r - T2r;\n                const FCi = T0i - T2i;\n                const FDr = T1r - T3i;\n                const FDi = T1i + T3r;\n                out[outOff] = FAr;\n                out[outOff + 1] = FAi;\n                out[outOff + 2] = FBr;\n                out[outOff + 3] = FBi;\n                out[outOff + 4] = FCr;\n                out[outOff + 5] = FCi;\n                out[outOff + 6] = FDr;\n                out[outOff + 7] = FDi;\n            };\n            // Real input radix-4 implementation\n            FFT.prototype._realTransform4 = function _realTransform4() {\n                var out = this._out;\n                var size = this._csize;\n                // Initial step (permute and transform)\n                var width = this._width;\n                var step = 1 << width;\n                var len = size / step << 1;\n                var outOff;\n                var t;\n                var bitrev = this._bitrev;\n                if (len === 4) for(outOff = 0, t = 0; outOff < size; outOff += len, t++){\n                    const off = bitrev[t];\n                    this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n                }\n                else // len === 8\n                for(outOff = 0, t = 0; outOff < size; outOff += len, t++){\n                    const off = bitrev[t];\n                    this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n                }\n                // Loop through steps in decreasing order\n                var inv = this._inv ? -1 : 1;\n                var table = this.table;\n                for(step >>= 2; step >= 2; step >>= 2){\n                    len = size / step << 1;\n                    var halfLen = len >>> 1;\n                    var quarterLen = halfLen >>> 1;\n                    var hquarterLen = quarterLen >>> 1;\n                    // Loop through offsets in the data\n                    for(outOff = 0; outOff < size; outOff += len)for(var i = 0, k = 0; i <= hquarterLen; i += 2, k += step){\n                        var A = outOff + i;\n                        var B = A + quarterLen;\n                        var C = B + quarterLen;\n                        var D = C + quarterLen;\n                        // Original values\n                        var Ar = out[A];\n                        var Ai = out[A + 1];\n                        var Br = out[B];\n                        var Bi = out[B + 1];\n                        var Cr = out[C];\n                        var Ci = out[C + 1];\n                        var Dr = out[D];\n                        var Di = out[D + 1];\n                        // Middle values\n                        var MAr = Ar;\n                        var MAi = Ai;\n                        var tableBr = table[k];\n                        var tableBi = inv * table[k + 1];\n                        var MBr = Br * tableBr - Bi * tableBi;\n                        var MBi = Br * tableBi + Bi * tableBr;\n                        var tableCr = table[2 * k];\n                        var tableCi = inv * table[2 * k + 1];\n                        var MCr = Cr * tableCr - Ci * tableCi;\n                        var MCi = Cr * tableCi + Ci * tableCr;\n                        var tableDr = table[3 * k];\n                        var tableDi = inv * table[3 * k + 1];\n                        var MDr = Dr * tableDr - Di * tableDi;\n                        var MDi = Dr * tableDi + Di * tableDr;\n                        // Pre-Final values\n                        var T0r = MAr + MCr;\n                        var T0i = MAi + MCi;\n                        var T1r = MAr - MCr;\n                        var T1i = MAi - MCi;\n                        var T2r = MBr + MDr;\n                        var T2i = MBi + MDi;\n                        var T3r = inv * (MBr - MDr);\n                        var T3i = inv * (MBi - MDi);\n                        // Final values\n                        var FAr = T0r + T2r;\n                        var FAi = T0i + T2i;\n                        var FBr = T1r + T3i;\n                        var FBi = T1i - T3r;\n                        out[A] = FAr;\n                        out[A + 1] = FAi;\n                        out[B] = FBr;\n                        out[B + 1] = FBi;\n                        // Output final middle point\n                        if (i === 0) {\n                            var FCr = T0r - T2r;\n                            var FCi = T0i - T2i;\n                            out[C] = FCr;\n                            out[C + 1] = FCi;\n                            continue;\n                        }\n                        // Do not overwrite ourselves\n                        if (i === hquarterLen) continue;\n                        // In the flipped case:\n                        // MAi = -MAi\n                        // MBr=-MBi, MBi=-MBr\n                        // MCr=-MCr\n                        // MDr=MDi, MDi=MDr\n                        var ST0r = T1r;\n                        var ST0i = -T1i;\n                        var ST1r = T0r;\n                        var ST1i = -T0i;\n                        var ST2r = -inv * T3i;\n                        var ST2i = -inv * T3r;\n                        var ST3r = -inv * T2i;\n                        var ST3i = -inv * T2r;\n                        var SFAr = ST0r + ST2r;\n                        var SFAi = ST0i + ST2i;\n                        var SFBr = ST1r + ST3i;\n                        var SFBi = ST1i - ST3r;\n                        var SA = outOff + quarterLen - i;\n                        var SB = outOff + halfLen - i;\n                        out[SA] = SFAr;\n                        out[SA + 1] = SFAi;\n                        out[SB] = SFBr;\n                        out[SB + 1] = SFBi;\n                    }\n                }\n            };\n            // radix-2 implementation\n            //\n            // NOTE: Only called for len=4\n            FFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff, off, step) {\n                const out = this._out;\n                const data = this._data;\n                const evenR = data[off];\n                const oddR = data[off + step];\n                const leftR = evenR + oddR;\n                const rightR = evenR - oddR;\n                out[outOff] = leftR;\n                out[outOff + 1] = 0;\n                out[outOff + 2] = rightR;\n                out[outOff + 3] = 0;\n            };\n            // radix-4\n            //\n            // NOTE: Only called for len=8\n            FFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff, off, step) {\n                const out = this._out;\n                const data = this._data;\n                const inv = this._inv ? -1 : 1;\n                const step2 = step * 2;\n                const step3 = step * 3;\n                // Original values\n                const Ar = data[off];\n                const Br = data[off + step];\n                const Cr = data[off + step2];\n                const Dr = data[off + step3];\n                // Pre-Final values\n                const T0r = Ar + Cr;\n                const T1r = Ar - Cr;\n                const T2r = Br + Dr;\n                const T3r = inv * (Br - Dr);\n                // Final values\n                const FAr = T0r + T2r;\n                const FBr = T1r;\n                const FBi = -T3r;\n                const FCr = T0r - T2r;\n                const FDr = T1r;\n                const FDi = T3r;\n                out[outOff] = FAr;\n                out[outOff + 1] = 0;\n                out[outOff + 2] = FBr;\n                out[outOff + 3] = FBi;\n                out[outOff + 4] = FCr;\n                out[outOff + 5] = 0;\n                out[outOff + 6] = FDr;\n                out[outOff + 7] = FDi;\n            };\n        },\n        {}\n    ],\n    2: [\n        function(require, module, exports) {\n            \"use strict\";\n            const WEBAUDIO_BLOCK_SIZE = 128;\n            /** Overlap-Add Node */ class OLAProcessor extends AudioWorkletProcessor {\n                /** Handles dynamic reallocation of input/output channels buffer\n     (channel numbers may vary during lifecycle) **/ reallocateChannelsIfNeeded(inputs, outputs) {\n                    for(var i = 0; i < this.nbInputs; i++){\n                        let nbChannels = inputs[i].length;\n                        if (nbChannels != this.inputBuffers[i].length) this.allocateInputChannels(i, nbChannels);\n                    }\n                    for(var i = 0; i < this.nbOutputs; i++){\n                        let nbChannels = outputs[i].length;\n                        if (nbChannels != this.outputBuffers[i].length) this.allocateOutputChannels(i, nbChannels);\n                    }\n                }\n                allocateInputChannels(inputIndex, nbChannels) {\n                    // allocate input buffers\n                    this.inputBuffers[inputIndex] = new Array(nbChannels);\n                    for(var i = 0; i < nbChannels; i++){\n                        this.inputBuffers[inputIndex][i] = new Float32Array(this.blockSize + WEBAUDIO_BLOCK_SIZE);\n                        this.inputBuffers[inputIndex][i].fill(0);\n                    }\n                    // allocate input buffers to send and head pointers to copy from\n                    // (cannot directly send a pointer/subarray because input may be modified)\n                    this.inputBuffersHead[inputIndex] = new Array(nbChannels);\n                    this.inputBuffersToSend[inputIndex] = new Array(nbChannels);\n                    for(var i = 0; i < nbChannels; i++){\n                        this.inputBuffersHead[inputIndex][i] = this.inputBuffers[inputIndex][i].subarray(0, this.blockSize);\n                        this.inputBuffersToSend[inputIndex][i] = new Float32Array(this.blockSize);\n                    }\n                }\n                allocateOutputChannels(outputIndex, nbChannels) {\n                    // allocate output buffers\n                    this.outputBuffers[outputIndex] = new Array(nbChannels);\n                    for(var i = 0; i < nbChannels; i++){\n                        this.outputBuffers[outputIndex][i] = new Float32Array(this.blockSize);\n                        this.outputBuffers[outputIndex][i].fill(0);\n                    }\n                    // allocate output buffers to retrieve\n                    // (cannot send a pointer/subarray because new output has to be add to exising output)\n                    this.outputBuffersToRetrieve[outputIndex] = new Array(nbChannels);\n                    for(var i = 0; i < nbChannels; i++){\n                        this.outputBuffersToRetrieve[outputIndex][i] = new Float32Array(this.blockSize);\n                        this.outputBuffersToRetrieve[outputIndex][i].fill(0);\n                    }\n                }\n                /** Read next web audio block to input buffers **/ readInputs(inputs) {\n                    // when playback is paused, we may stop receiving new samples\n                    if (inputs[0].length && inputs[0][0].length == 0) {\n                        for(var i = 0; i < this.nbInputs; i++)for(var j = 0; j < this.inputBuffers[i].length; j++)this.inputBuffers[i][j].fill(0, this.blockSize);\n                        return;\n                    }\n                    for(var i = 0; i < this.nbInputs; i++)for(var j = 0; j < this.inputBuffers[i].length; j++){\n                        let webAudioBlock = inputs[i][j];\n                        this.inputBuffers[i][j].set(webAudioBlock, this.blockSize);\n                    }\n                }\n                /** Write next web audio block from output buffers **/ writeOutputs(outputs) {\n                    for(var i = 0; i < this.nbInputs; i++)for(var j = 0; j < this.inputBuffers[i].length; j++){\n                        let webAudioBlock = this.outputBuffers[i][j].subarray(0, WEBAUDIO_BLOCK_SIZE);\n                        outputs[i][j].set(webAudioBlock);\n                    }\n                }\n                /** Shift left content of input buffers to receive new web audio block **/ shiftInputBuffers() {\n                    for(var i = 0; i < this.nbInputs; i++)for(var j = 0; j < this.inputBuffers[i].length; j++)this.inputBuffers[i][j].copyWithin(0, WEBAUDIO_BLOCK_SIZE);\n                }\n                /** Shift left content of output buffers to receive new web audio block **/ shiftOutputBuffers() {\n                    for(var i = 0; i < this.nbOutputs; i++)for(var j = 0; j < this.outputBuffers[i].length; j++){\n                        this.outputBuffers[i][j].copyWithin(0, WEBAUDIO_BLOCK_SIZE);\n                        this.outputBuffers[i][j].subarray(this.blockSize - WEBAUDIO_BLOCK_SIZE).fill(0);\n                    }\n                }\n                /** Copy contents of input buffers to buffer actually sent to process **/ prepareInputBuffersToSend() {\n                    for(var i = 0; i < this.nbInputs; i++)for(var j = 0; j < this.inputBuffers[i].length; j++)this.inputBuffersToSend[i][j].set(this.inputBuffersHead[i][j]);\n                }\n                /** Add contents of output buffers just processed to output buffers **/ handleOutputBuffersToRetrieve() {\n                    for(var i = 0; i < this.nbOutputs; i++){\n                        for(var j = 0; j < this.outputBuffers[i].length; j++)for(var k = 0; k < this.blockSize; k++)this.outputBuffers[i][j][k] += this.outputBuffersToRetrieve[i][j][k] / this.nbOverlaps;\n                    }\n                }\n                process(inputs, outputs, params) {\n                    this.reallocateChannelsIfNeeded(inputs, outputs);\n                    this.readInputs(inputs);\n                    this.shiftInputBuffers();\n                    this.prepareInputBuffersToSend();\n                    this.processOLA(this.inputBuffersToSend, this.outputBuffersToRetrieve, params);\n                    this.handleOutputBuffersToRetrieve();\n                    this.writeOutputs(outputs);\n                    this.shiftOutputBuffers();\n                    return true;\n                }\n                processOLA(inputs, outputs, params) {\n                    console.assert(false, \"Not overriden\");\n                }\n                constructor(options){\n                    super(options);\n                    this.nbInputs = options.numberOfInputs;\n                    this.nbOutputs = options.numberOfOutputs;\n                    this.blockSize = options.processorOptions.blockSize;\n                    // TODO for now, the only support hop size is the size of a web audio block\n                    this.hopSize = WEBAUDIO_BLOCK_SIZE;\n                    this.nbOverlaps = this.blockSize / this.hopSize;\n                    // pre-allocate input buffers (will be reallocated if needed)\n                    this.inputBuffers = new Array(this.nbInputs);\n                    this.inputBuffersHead = new Array(this.nbInputs);\n                    this.inputBuffersToSend = new Array(this.nbInputs);\n                    // default to 1 channel per input until we know more\n                    for(var i = 0; i < this.nbInputs; i++)this.allocateInputChannels(i, 1);\n                    // pre-allocate input buffers (will be reallocated if needed)\n                    this.outputBuffers = new Array(this.nbOutputs);\n                    this.outputBuffersToRetrieve = new Array(this.nbOutputs);\n                    // default to 1 channel per output until we know more\n                    for(var i = 0; i < this.nbOutputs; i++)this.allocateOutputChannels(i, 1);\n                }\n            }\n            module.exports = OLAProcessor;\n        },\n        {}\n    ],\n    3: [\n        function(require, module, exports) {\n            \"use strict\";\n            const OLAProcessor = require(\"./ola-processor.js\");\n            const FFT = require(\"fft.js\");\n            const BUFFERED_BLOCK_SIZE = 2048;\n            function genHannWindow(length) {\n                let win = new Float32Array(length);\n                for(var i = 0; i < length; i++)win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / length));\n                return win;\n            }\n            class PhaseVocoderProcessor extends OLAProcessor {\n                static get parameterDescriptors() {\n                    return [\n                        {\n                            name: \"pitchFactor\",\n                            defaultValue: 1.0\n                        }\n                    ];\n                }\n                processOLA(inputs, outputs, parameters) {\n                    // no automation, take last value\n                    const pitchFactor = parameters.pitchFactor[parameters.pitchFactor.length - 1];\n                    for(var i = 0; i < this.nbInputs; i++)for(var j = 0; j < inputs[i].length; j++){\n                        // big assumption here: output is symetric to input\n                        var input = inputs[i][j];\n                        var output = outputs[i][j];\n                        this.applyHannWindow(input);\n                        this.fft.realTransform(this.freqComplexBuffer, input);\n                        this.computeMagnitudes();\n                        this.findPeaks();\n                        this.shiftPeaks(pitchFactor);\n                        this.fft.completeSpectrum(this.freqComplexBufferShifted);\n                        this.fft.inverseTransform(this.timeComplexBuffer, this.freqComplexBufferShifted);\n                        this.fft.fromComplexArray(this.timeComplexBuffer, output);\n                        this.applyHannWindow(output);\n                    }\n                    this.timeCursor += this.hopSize;\n                }\n                /** Apply Hann window in-place */ applyHannWindow(input) {\n                    for(var i = 0; i < this.blockSize; i++)input[i] = input[i] * this.hannWindow[i];\n                }\n                /** Compute squared magnitudes for peak finding **/ computeMagnitudes() {\n                    var i = 0, j = 0;\n                    while(i < this.magnitudes.length){\n                        let real = this.freqComplexBuffer[j];\n                        let imag = this.freqComplexBuffer[j + 1];\n                        // no need to sqrt for peak finding\n                        this.magnitudes[i] = real ** 2 + imag ** 2;\n                        i += 1;\n                        j += 2;\n                    }\n                }\n                /** Find peaks in spectrum magnitudes **/ findPeaks() {\n                    this.nbPeaks = 0;\n                    var i = 2;\n                    let end = this.magnitudes.length - 2;\n                    while(i < end){\n                        let mag = this.magnitudes[i];\n                        if (this.magnitudes[i - 1] >= mag || this.magnitudes[i - 2] >= mag) {\n                            i++;\n                            continue;\n                        }\n                        if (this.magnitudes[i + 1] >= mag || this.magnitudes[i + 2] >= mag) {\n                            i++;\n                            continue;\n                        }\n                        this.peakIndexes[this.nbPeaks] = i;\n                        this.nbPeaks++;\n                        i += 2;\n                    }\n                }\n                /** Shift peaks and regions of influence by pitchFactor into new specturm */ shiftPeaks(pitchFactor) {\n                    // zero-fill new spectrum\n                    this.freqComplexBufferShifted.fill(0);\n                    for(var i = 0; i < this.nbPeaks; i++){\n                        let peakIndex = this.peakIndexes[i];\n                        let peakIndexShifted = Math.round(peakIndex * pitchFactor);\n                        if (peakIndexShifted > this.magnitudes.length) break;\n                        // find region of influence\n                        var startIndex = 0;\n                        var endIndex = this.fftSize;\n                        if (i > 0) {\n                            let peakIndexBefore = this.peakIndexes[i - 1];\n                            startIndex = peakIndex - Math.floor((peakIndex - peakIndexBefore) / 2);\n                        }\n                        if (i < this.nbPeaks - 1) {\n                            let peakIndexAfter = this.peakIndexes[i + 1];\n                            endIndex = peakIndex + Math.ceil((peakIndexAfter - peakIndex) / 2);\n                        }\n                        // shift whole region of influence around peak to shifted peak\n                        let startOffset = startIndex - peakIndex;\n                        let endOffset = endIndex - peakIndex;\n                        for(var j = startOffset; j < endOffset; j++){\n                            let binIndex = peakIndex + j;\n                            let binIndexShifted = peakIndexShifted + j;\n                            if (binIndexShifted >= this.magnitudes.length) break;\n                            // apply phase correction\n                            let omegaDelta = 2 * Math.PI * (binIndexShifted - binIndex) / this.fftSize;\n                            let phaseShiftReal = Math.cos(omegaDelta * this.timeCursor);\n                            let phaseShiftImag = Math.sin(omegaDelta * this.timeCursor);\n                            let indexReal = binIndex * 2;\n                            let indexImag = indexReal + 1;\n                            let valueReal = this.freqComplexBuffer[indexReal];\n                            let valueImag = this.freqComplexBuffer[indexImag];\n                            let valueShiftedReal = valueReal * phaseShiftReal - valueImag * phaseShiftImag;\n                            let valueShiftedImag = valueReal * phaseShiftImag + valueImag * phaseShiftReal;\n                            let indexShiftedReal = binIndexShifted * 2;\n                            let indexShiftedImag = indexShiftedReal + 1;\n                            this.freqComplexBufferShifted[indexShiftedReal] += valueShiftedReal;\n                            this.freqComplexBufferShifted[indexShiftedImag] += valueShiftedImag;\n                        }\n                    }\n                }\n                constructor(options){\n                    options.processorOptions = {\n                        blockSize: BUFFERED_BLOCK_SIZE\n                    };\n                    super(options);\n                    this.fftSize = this.blockSize;\n                    this.timeCursor = 0;\n                    this.hannWindow = genHannWindow(this.blockSize);\n                    // prepare FFT and pre-allocate buffers\n                    this.fft = new FFT(this.fftSize);\n                    this.freqComplexBuffer = this.fft.createComplexArray();\n                    this.freqComplexBufferShifted = this.fft.createComplexArray();\n                    this.timeComplexBuffer = this.fft.createComplexArray();\n                    this.magnitudes = new Float32Array(this.fftSize / 2 + 1);\n                    this.peakIndexes = new Int32Array(this.magnitudes.length);\n                    this.nbPeaks = 0;\n                }\n            }\n            registerProcessor(\"phase-vocoder-processor\", PhaseVocoderProcessor);\n        },\n        {\n            \"./ola-processor.js\": 2,\n            \"fft.js\": 1\n        }\n    ]\n}, {}, [\n    3\n]);\n\n},{}]},[\"jWRiz\"], \"jWRiz\", \"parcelRequirec6d8\")\n\n//# sourceMappingURL=phase-vocoder.7a851a40.js.map\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nfunction FFT(size) {\n  this.size = size | 0;\n  if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n    throw new Error('FFT size must be a power of two and bigger than 1');\n\n  this._csize = size << 1;\n\n  // NOTE: Use of `var` is intentional for old V8 versions\n  var table = new Array(this.size * 2);\n  for (var i = 0; i < table.length; i += 2) {\n    const angle = Math.PI * i / this.size;\n    table[i] = Math.cos(angle);\n    table[i + 1] = -Math.sin(angle);\n  }\n  this.table = table;\n\n  // Find size's power of two\n  var power = 0;\n  for (var t = 1; this.size > t; t <<= 1)\n    power++;\n\n  // Calculate initial step's width:\n  //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n  //   * Otherwise it is the same as `power` to give len=4\n  this._width = power % 2 === 0 ? power - 1 : power;\n\n  // Pre-compute bit-reversal patterns\n  this._bitrev = new Array(1 << this._width);\n  for (var j = 0; j < this._bitrev.length; j++) {\n    this._bitrev[j] = 0;\n    for (var shift = 0; shift < this._width; shift += 2) {\n      var revShift = this._width - shift - 2;\n      this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n    }\n  }\n\n  this._out = null;\n  this._data = null;\n  this._inv = 0;\n}\nmodule.exports = FFT;\n\nFFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {\n  var res = storage || new Array(complex.length >>> 1);\n  for (var i = 0; i < complex.length; i += 2)\n    res[i >>> 1] = complex[i];\n  return res;\n};\n\nFFT.prototype.createComplexArray = function createComplexArray() {\n  const res = new Array(this._csize);\n  for (var i = 0; i < res.length; i++)\n    res[i] = 0;\n  return res;\n};\n\nFFT.prototype.toComplexArray = function toComplexArray(input, storage) {\n  var res = storage || this.createComplexArray();\n  for (var i = 0; i < res.length; i += 2) {\n    res[i] = input[i >>> 1];\n    res[i + 1] = 0;\n  }\n  return res;\n};\n\nFFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {\n  var size = this._csize;\n  var half = size >>> 1;\n  for (var i = 2; i < half; i += 2) {\n    spectrum[size - i] = spectrum[i];\n    spectrum[size - i + 1] = -spectrum[i + 1];\n  }\n};\n\nFFT.prototype.transform = function transform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._transform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.realTransform = function realTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._realTransform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.inverseTransform = function inverseTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 1;\n  this._transform4();\n  for (var i = 0; i < out.length; i++)\n    out[i] /= this.size;\n  this._out = null;\n  this._data = null;\n};\n\n// radix-4 implementation\n//\n// NOTE: Uses of `var` are intentional for older V8 version that do not\n// support both `let compound assignments` and `const phi`\nFFT.prototype._transform4 = function _transform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform2(outOff, off, step);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform4(outOff, off, step);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var quarterLen = len >>> 2;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      // Full case\n      var limit = outOff + quarterLen;\n      for (var i = outOff, k = 0; i < limit; i += 2, k += step) {\n        const A = i;\n        const B = A + quarterLen;\n        const C = B + quarterLen;\n        const D = C + quarterLen;\n\n        // Original values\n        const Ar = out[A];\n        const Ai = out[A + 1];\n        const Br = out[B];\n        const Bi = out[B + 1];\n        const Cr = out[C];\n        const Ci = out[C + 1];\n        const Dr = out[D];\n        const Di = out[D + 1];\n\n        // Middle values\n        const MAr = Ar;\n        const MAi = Ai;\n\n        const tableBr = table[k];\n        const tableBi = inv * table[k + 1];\n        const MBr = Br * tableBr - Bi * tableBi;\n        const MBi = Br * tableBi + Bi * tableBr;\n\n        const tableCr = table[2 * k];\n        const tableCi = inv * table[2 * k + 1];\n        const MCr = Cr * tableCr - Ci * tableCi;\n        const MCi = Cr * tableCi + Ci * tableCr;\n\n        const tableDr = table[3 * k];\n        const tableDi = inv * table[3 * k + 1];\n        const MDr = Dr * tableDr - Di * tableDi;\n        const MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        const T0r = MAr + MCr;\n        const T0i = MAi + MCi;\n        const T1r = MAr - MCr;\n        const T1i = MAi - MCi;\n        const T2r = MBr + MDr;\n        const T2i = MBi + MDi;\n        const T3r = inv * (MBr - MDr);\n        const T3i = inv * (MBi - MDi);\n\n        // Final values\n        const FAr = T0r + T2r;\n        const FAi = T0i + T2i;\n\n        const FCr = T0r - T2r;\n        const FCi = T0i - T2i;\n\n        const FBr = T1r + T3i;\n        const FBi = T1i - T3r;\n\n        const FDr = T1r - T3i;\n        const FDi = T1i + T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n        out[C] = FCr;\n        out[C + 1] = FCi;\n        out[D] = FDr;\n        out[D + 1] = FDi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleTransform2 = function _singleTransform2(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const evenI = data[off + 1];\n  const oddR = data[off + step];\n  const oddI = data[off + step + 1];\n\n  const leftR = evenR + oddR;\n  const leftI = evenI + oddI;\n  const rightR = evenR - oddR;\n  const rightI = evenI - oddI;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = leftI;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = rightI;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleTransform4 = function _singleTransform4(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Ai = data[off + 1];\n  const Br = data[off + step];\n  const Bi = data[off + step + 1];\n  const Cr = data[off + step2];\n  const Ci = data[off + step2 + 1];\n  const Dr = data[off + step3];\n  const Di = data[off + step3 + 1];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T0i = Ai + Ci;\n  const T1r = Ar - Cr;\n  const T1i = Ai - Ci;\n  const T2r = Br + Dr;\n  const T2i = Bi + Di;\n  const T3r = inv * (Br - Dr);\n  const T3i = inv * (Bi - Di);\n\n  // Final values\n  const FAr = T0r + T2r;\n  const FAi = T0i + T2i;\n\n  const FBr = T1r + T3i;\n  const FBi = T1i - T3r;\n\n  const FCr = T0r - T2r;\n  const FCi = T0i - T2i;\n\n  const FDr = T1r - T3i;\n  const FDi = T1i + T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = FAi;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = FCi;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n\n// Real input radix-4 implementation\nFFT.prototype._realTransform4 = function _realTransform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var halfLen = len >>> 1;\n    var quarterLen = halfLen >>> 1;\n    var hquarterLen = quarterLen >>> 1;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n        var A = outOff + i;\n        var B = A + quarterLen;\n        var C = B + quarterLen;\n        var D = C + quarterLen;\n\n        // Original values\n        var Ar = out[A];\n        var Ai = out[A + 1];\n        var Br = out[B];\n        var Bi = out[B + 1];\n        var Cr = out[C];\n        var Ci = out[C + 1];\n        var Dr = out[D];\n        var Di = out[D + 1];\n\n        // Middle values\n        var MAr = Ar;\n        var MAi = Ai;\n\n        var tableBr = table[k];\n        var tableBi = inv * table[k + 1];\n        var MBr = Br * tableBr - Bi * tableBi;\n        var MBi = Br * tableBi + Bi * tableBr;\n\n        var tableCr = table[2 * k];\n        var tableCi = inv * table[2 * k + 1];\n        var MCr = Cr * tableCr - Ci * tableCi;\n        var MCi = Cr * tableCi + Ci * tableCr;\n\n        var tableDr = table[3 * k];\n        var tableDi = inv * table[3 * k + 1];\n        var MDr = Dr * tableDr - Di * tableDi;\n        var MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        var T0r = MAr + MCr;\n        var T0i = MAi + MCi;\n        var T1r = MAr - MCr;\n        var T1i = MAi - MCi;\n        var T2r = MBr + MDr;\n        var T2i = MBi + MDi;\n        var T3r = inv * (MBr - MDr);\n        var T3i = inv * (MBi - MDi);\n\n        // Final values\n        var FAr = T0r + T2r;\n        var FAi = T0i + T2i;\n\n        var FBr = T1r + T3i;\n        var FBi = T1i - T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n\n        // Output final middle point\n        if (i === 0) {\n          var FCr = T0r - T2r;\n          var FCi = T0i - T2i;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          continue;\n        }\n\n        // Do not overwrite ourselves\n        if (i === hquarterLen)\n          continue;\n\n        // In the flipped case:\n        // MAi = -MAi\n        // MBr=-MBi, MBi=-MBr\n        // MCr=-MCr\n        // MDr=MDi, MDi=MDr\n        var ST0r = T1r;\n        var ST0i = -T1i;\n        var ST1r = T0r;\n        var ST1i = -T0i;\n        var ST2r = -inv * T3i;\n        var ST2i = -inv * T3r;\n        var ST3r = -inv * T2i;\n        var ST3i = -inv * T2r;\n\n        var SFAr = ST0r + ST2r;\n        var SFAi = ST0i + ST2i;\n\n        var SFBr = ST1r + ST3i;\n        var SFBi = ST1i - ST3r;\n\n        var SA = outOff + quarterLen - i;\n        var SB = outOff + halfLen - i;\n\n        out[SA] = SFAr;\n        out[SA + 1] = SFAi;\n        out[SB] = SFBr;\n        out[SB + 1] = SFBi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const oddR = data[off + step];\n\n  const leftR = evenR + oddR;\n  const rightR = evenR - oddR;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = 0;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Br = data[off + step];\n  const Cr = data[off + step2];\n  const Dr = data[off + step3];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T1r = Ar - Cr;\n  const T2r = Br + Dr;\n  const T3r = inv * (Br - Dr);\n\n  // Final values\n  const FAr = T0r + T2r;\n\n  const FBr = T1r;\n  const FBi = -T3r;\n\n  const FCr = T0r - T2r;\n\n  const FDr = T1r;\n  const FDi = T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = 0;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\n\nconst WEBAUDIO_BLOCK_SIZE = 128;\n\n/** Overlap-Add Node */\nclass OLAProcessor extends AudioWorkletProcessor {\n    constructor(options) {\n        super(options);\n\n        this.nbInputs = options.numberOfInputs;\n        this.nbOutputs = options.numberOfOutputs;\n\n        this.blockSize = options.processorOptions.blockSize;\n         // TODO for now, the only support hop size is the size of a web audio block\n        this.hopSize = WEBAUDIO_BLOCK_SIZE;\n\n        this.nbOverlaps = this.blockSize / this.hopSize;\n\n        // pre-allocate input buffers (will be reallocated if needed)\n        this.inputBuffers = new Array(this.nbInputs);\n        this.inputBuffersHead = new Array(this.nbInputs);\n        this.inputBuffersToSend = new Array(this.nbInputs);\n        // default to 1 channel per input until we know more\n        for (var i = 0; i < this.nbInputs; i++) {\n            this.allocateInputChannels(i, 1);\n        }\n        // pre-allocate input buffers (will be reallocated if needed)\n        this.outputBuffers = new Array(this.nbOutputs);\n        this.outputBuffersToRetrieve = new Array(this.nbOutputs);\n        // default to 1 channel per output until we know more\n        for (var i = 0; i < this.nbOutputs; i++) {\n            this.allocateOutputChannels(i, 1);\n        }\n    }\n\n    /** Handles dynamic reallocation of input/output channels buffer\n     (channel numbers may vary during lifecycle) **/\n    reallocateChannelsIfNeeded(inputs, outputs) {\n        for (var i = 0; i < this.nbInputs; i++) {\n            let nbChannels = inputs[i].length;\n            if (nbChannels != this.inputBuffers[i].length) {\n                this.allocateInputChannels(i, nbChannels);\n            }\n        }\n\n        for (var i = 0; i < this.nbOutputs; i++) {\n            let nbChannels = outputs[i].length;\n            if (nbChannels != this.outputBuffers[i].length) {\n                this.allocateOutputChannels(i, nbChannels);\n            }\n        }\n    }\n\n    allocateInputChannels(inputIndex, nbChannels) {\n        // allocate input buffers\n\n        this.inputBuffers[inputIndex] = new Array(nbChannels);\n        for (var i = 0; i < nbChannels; i++) {\n            this.inputBuffers[inputIndex][i] = new Float32Array(this.blockSize + WEBAUDIO_BLOCK_SIZE);\n            this.inputBuffers[inputIndex][i].fill(0);\n        }\n\n        // allocate input buffers to send and head pointers to copy from\n        // (cannot directly send a pointer/subarray because input may be modified)\n        this.inputBuffersHead[inputIndex] = new Array(nbChannels);\n        this.inputBuffersToSend[inputIndex] = new Array(nbChannels);\n        for (var i = 0; i < nbChannels; i++) {\n            this.inputBuffersHead[inputIndex][i] = this.inputBuffers[inputIndex][i] .subarray(0, this.blockSize);\n            this.inputBuffersToSend[inputIndex][i] = new Float32Array(this.blockSize);\n        }\n    }\n\n    allocateOutputChannels(outputIndex, nbChannels) {\n        // allocate output buffers\n        this.outputBuffers[outputIndex] = new Array(nbChannels);\n        for (var i = 0; i < nbChannels; i++) {\n            this.outputBuffers[outputIndex][i] = new Float32Array(this.blockSize);\n            this.outputBuffers[outputIndex][i].fill(0);\n        }\n\n        // allocate output buffers to retrieve\n        // (cannot send a pointer/subarray because new output has to be add to exising output)\n        this.outputBuffersToRetrieve[outputIndex] = new Array(nbChannels);\n        for (var i = 0; i < nbChannels; i++) {\n            this.outputBuffersToRetrieve[outputIndex][i] = new Float32Array(this.blockSize);\n            this.outputBuffersToRetrieve[outputIndex][i].fill(0);\n        }\n    }\n\n    /** Read next web audio block to input buffers **/\n    readInputs(inputs) {\n        // when playback is paused, we may stop receiving new samples\n        if (inputs[0].length && inputs[0][0].length == 0) {\n            for (var i = 0; i < this.nbInputs; i++) {\n                for (var j = 0; j < this.inputBuffers[i].length; j++) {\n                    this.inputBuffers[i][j].fill(0, this.blockSize);\n                }\n            }\n            return;\n        }\n\n        for (var i = 0; i < this.nbInputs; i++) {\n            for (var j = 0; j < this.inputBuffers[i].length; j++) {\n                let webAudioBlock = inputs[i][j];\n                this.inputBuffers[i][j].set(webAudioBlock, this.blockSize);\n            }\n        }\n    }\n\n    /** Write next web audio block from output buffers **/\n    writeOutputs(outputs) {\n        for (var i = 0; i < this.nbInputs; i++) {\n            for (var j = 0; j < this.inputBuffers[i].length; j++) {\n                let webAudioBlock = this.outputBuffers[i][j].subarray(0, WEBAUDIO_BLOCK_SIZE);\n                outputs[i][j].set(webAudioBlock);\n            }\n        }\n    }\n\n    /** Shift left content of input buffers to receive new web audio block **/\n    shiftInputBuffers() {\n        for (var i = 0; i < this.nbInputs; i++) {\n            for (var j = 0; j < this.inputBuffers[i].length; j++) {\n                this.inputBuffers[i][j].copyWithin(0, WEBAUDIO_BLOCK_SIZE);\n            }\n        }\n    }\n\n    /** Shift left content of output buffers to receive new web audio block **/\n    shiftOutputBuffers() {\n        for (var i = 0; i < this.nbOutputs; i++) {\n            for (var j = 0; j < this.outputBuffers[i].length; j++) {\n                this.outputBuffers[i][j].copyWithin(0, WEBAUDIO_BLOCK_SIZE);\n                this.outputBuffers[i][j].subarray(this.blockSize - WEBAUDIO_BLOCK_SIZE).fill(0);\n            }\n        }\n    }\n\n    /** Copy contents of input buffers to buffer actually sent to process **/\n    prepareInputBuffersToSend() {\n        for (var i = 0; i < this.nbInputs; i++) {\n            for (var j = 0; j < this.inputBuffers[i].length; j++) {\n                this.inputBuffersToSend[i][j].set(this.inputBuffersHead[i][j]);\n            }\n        }\n    }\n\n    /** Add contents of output buffers just processed to output buffers **/\n    handleOutputBuffersToRetrieve() {\n        for (var i = 0; i < this.nbOutputs; i++) {\n            for (var j = 0; j < this.outputBuffers[i].length; j++) {\n                for (var k = 0; k < this.blockSize; k++) {\n                    this.outputBuffers[i][j][k] += this.outputBuffersToRetrieve[i][j][k] / this.nbOverlaps;\n                }\n            }\n        }\n    }\n\n    process(inputs, outputs, params) {\n        this.reallocateChannelsIfNeeded(inputs, outputs);\n\n        this.readInputs(inputs);\n        this.shiftInputBuffers();\n        this.prepareInputBuffersToSend()\n        this.processOLA(this.inputBuffersToSend, this.outputBuffersToRetrieve, params);\n        this.handleOutputBuffersToRetrieve();\n        this.writeOutputs(outputs);\n        this.shiftOutputBuffers();\n\n        return true;\n    }\n\n    processOLA(inputs, outputs, params) {\n        console.assert(false, \"Not overriden\");\n    }\n}\n\nmodule.exports = OLAProcessor;\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nconst OLAProcessor = require('./ola-processor.js');\nconst FFT = require('fft.js');\n\nconst BUFFERED_BLOCK_SIZE = 2048;\n\nfunction genHannWindow(length) {\n    let win = new Float32Array(length);\n    for (var i = 0; i < length; i++) {\n        win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / length));\n    }\n    return win;\n}\n\nclass PhaseVocoderProcessor extends OLAProcessor {\n    static get parameterDescriptors() {\n        return [{\n            name: 'pitchFactor',\n            defaultValue: 1.0\n        }];\n    }\n\n    constructor(options) {\n        options.processorOptions = {\n            blockSize: BUFFERED_BLOCK_SIZE,\n        };\n        super(options);\n\n        this.fftSize = this.blockSize;\n        this.timeCursor = 0;\n\n        this.hannWindow = genHannWindow(this.blockSize);\n\n        // prepare FFT and pre-allocate buffers\n        this.fft = new FFT(this.fftSize);\n        this.freqComplexBuffer = this.fft.createComplexArray();\n        this.freqComplexBufferShifted = this.fft.createComplexArray();\n        this.timeComplexBuffer = this.fft.createComplexArray();\n        this.magnitudes = new Float32Array(this.fftSize / 2 + 1);\n        this.peakIndexes = new Int32Array(this.magnitudes.length);\n        this.nbPeaks = 0;\n    }\n\n    processOLA(inputs, outputs, parameters) {\n        // no automation, take last value\n        const pitchFactor = parameters.pitchFactor[parameters.pitchFactor.length - 1];\n\n        for (var i = 0; i < this.nbInputs; i++) {\n            for (var j = 0; j < inputs[i].length; j++) {\n                // big assumption here: output is symetric to input\n                var input = inputs[i][j];\n                var output = outputs[i][j];\n\n                this.applyHannWindow(input);\n\n                this.fft.realTransform(this.freqComplexBuffer, input);\n\n                this.computeMagnitudes();\n                this.findPeaks();\n                this.shiftPeaks(pitchFactor);\n\n                this.fft.completeSpectrum(this.freqComplexBufferShifted);\n                this.fft.inverseTransform(this.timeComplexBuffer, this.freqComplexBufferShifted);\n                this.fft.fromComplexArray(this.timeComplexBuffer, output);\n\n                this.applyHannWindow(output);\n            }\n        }\n\n        this.timeCursor += this.hopSize;\n    }\n\n    /** Apply Hann window in-place */\n    applyHannWindow(input) {\n        for (var i = 0; i < this.blockSize; i++) {\n            input[i] = input[i] * this.hannWindow[i];\n        }\n    }\n\n    /** Compute squared magnitudes for peak finding **/\n    computeMagnitudes() {\n        var i = 0, j = 0;\n        while (i < this.magnitudes.length) {\n            let real = this.freqComplexBuffer[j];\n            let imag = this.freqComplexBuffer[j + 1];\n            // no need to sqrt for peak finding\n            this.magnitudes[i] = real ** 2 + imag ** 2;\n            i+=1;\n            j+=2;\n        }\n    }\n\n    /** Find peaks in spectrum magnitudes **/\n    findPeaks() {\n        this.nbPeaks = 0;\n        var i = 2;\n        let end = this.magnitudes.length - 2;\n\n        while (i < end) {\n            let mag = this.magnitudes[i];\n\n            if (this.magnitudes[i - 1] >= mag || this.magnitudes[i - 2] >= mag) {\n                i++;\n                continue;\n            }\n            if (this.magnitudes[i + 1] >= mag || this.magnitudes[i + 2] >= mag) {\n                i++;\n                continue;\n            }\n\n            this.peakIndexes[this.nbPeaks] = i;\n            this.nbPeaks++;\n            i += 2;\n        }\n    }\n\n    /** Shift peaks and regions of influence by pitchFactor into new specturm */\n    shiftPeaks(pitchFactor) {\n        // zero-fill new spectrum\n        this.freqComplexBufferShifted.fill(0);\n\n        for (var i = 0; i < this.nbPeaks; i++) {\n            let peakIndex = this.peakIndexes[i];\n            let peakIndexShifted = Math.round(peakIndex * pitchFactor);\n\n            if (peakIndexShifted > this.magnitudes.length) {\n                break;\n            }\n\n            // find region of influence\n            var startIndex = 0;\n            var endIndex = this.fftSize;\n            if (i > 0) {\n                let peakIndexBefore = this.peakIndexes[i - 1];\n                startIndex = peakIndex - Math.floor((peakIndex - peakIndexBefore) / 2);\n            }\n            if (i < this.nbPeaks - 1) {\n                let peakIndexAfter = this.peakIndexes[i + 1];\n                endIndex = peakIndex + Math.ceil((peakIndexAfter - peakIndex) / 2);\n            }\n\n            // shift whole region of influence around peak to shifted peak\n            let startOffset = startIndex - peakIndex;\n            let endOffset = endIndex - peakIndex;\n            for (var j = startOffset; j < endOffset; j++) {\n                let binIndex = peakIndex + j;\n                let binIndexShifted = peakIndexShifted + j;\n\n                if (binIndexShifted >= this.magnitudes.length) {\n                    break;\n                }\n\n                // apply phase correction\n                let omegaDelta = 2 * Math.PI * (binIndexShifted - binIndex) / this.fftSize;\n                let phaseShiftReal = Math.cos(omegaDelta * this.timeCursor);\n                let phaseShiftImag = Math.sin(omegaDelta * this.timeCursor);\n\n                let indexReal = binIndex * 2;\n                let indexImag = indexReal + 1;\n                let valueReal = this.freqComplexBuffer[indexReal];\n                let valueImag = this.freqComplexBuffer[indexImag];\n\n                let valueShiftedReal = valueReal * phaseShiftReal - valueImag * phaseShiftImag;\n                let valueShiftedImag = valueReal * phaseShiftImag + valueImag * phaseShiftReal;\n\n                let indexShiftedReal = binIndexShifted * 2;\n                let indexShiftedImag = indexShiftedReal + 1;\n                this.freqComplexBufferShifted[indexShiftedReal] += valueShiftedReal;\n                this.freqComplexBufferShifted[indexShiftedImag] += valueShiftedImag;\n            }\n        }\n    }\n}\n\nregisterProcessor(\"phase-vocoder-processor\", PhaseVocoderProcessor);\n\n\n},{\"./ola-processor.js\":2,\"fft.js\":1}]},{},[3]);\n"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","r","e","n","t","o","f","c","undefined","u","a","p","FFT","size","_csize","table","Array","angle","Math","PI","cos","sin","power","_width","_bitrev","j","shift","revShift","_out","_data","_inv","prototype","fromComplexArray","complex","storage","createComplexArray","toComplexArray","input","completeSpectrum","spectrum","half","transform","out","data","_transform4","realTransform","_realTransform4","inverseTransform","outOff","step","len","bitrev","off","_singleTransform2","_singleTransform4","inv","quarterLen","limit","k","A","B","C","D","Ar","Ai","Br","Bi","Cr","Ci","Dr","Di","tableBr","tableBi","MBr","MBi","tableCr","tableCi","MCr","MCi","tableDr","tableDi","MDr","MDi","T0r","MAr","T0i","MAi","T1r","T1i","T2r","T2i","T3r","T3i","FAr","FAi","FCr","FCi","FBr","FBi","FDr","FDi","evenR","evenI","oddR","oddI","step2","step3","_singleRealTransform2","_singleRealTransform4","halfLen","hquarterLen","ST2r","ST2i","ST3r","SFAr","ST0r","SFAi","ST0i","SFBr","ST1r","SFBi","ST1i","SA","SB","OLAProcessor","AudioWorkletProcessor","reallocateChannelsIfNeeded","inputs","outputs","nbInputs","nbChannels","inputBuffers","allocateInputChannels","nbOutputs","outputBuffers","allocateOutputChannels","inputIndex","Float32Array","blockSize","fill","inputBuffersHead","inputBuffersToSend","subarray","outputIndex","outputBuffersToRetrieve","readInputs","webAudioBlock","set","writeOutputs","shiftInputBuffers","copyWithin","shiftOutputBuffers","prepareInputBuffersToSend","handleOutputBuffersToRetrieve","nbOverlaps","process","params","processOLA","console","assert","constructor","options","numberOfInputs","numberOfOutputs","processorOptions","hopSize","registerProcessor","parameterDescriptors","defaultValue","parameters","pitchFactor","output","applyHannWindow","fft","freqComplexBuffer","computeMagnitudes","findPeaks","shiftPeaks","freqComplexBufferShifted","timeComplexBuffer","timeCursor","hannWindow","magnitudes","real","imag","nbPeaks","end","mag","peakIndexes","peakIndex","peakIndexShifted","round","startIndex","endIndex","fftSize","floor","ceil","peakIndexAfter","startOffset","endOffset","binIndex","binIndexShifted","omegaDelta","phaseShiftReal","phaseShiftImag","indexReal","indexImag","valueReal","valueImag","valueShiftedReal","valueShiftedImag","indexShiftedReal","indexShiftedImag","genHannWindow","win","Int32Array"],"version":3,"file":"phase-vocoder.7a851a40.js.map"}