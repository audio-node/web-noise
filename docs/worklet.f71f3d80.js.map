{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,M,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GCKA,EAAA,MAAA,CAAA,EAAA,wBAAA,IAAa,GALb,IAAA,EAAA,EAAA,UACA,EAAA,EAAA,sBAIM,OAAO,UAA8B,sBACzC,YAAc,CAAE,AAChB,CAAA,OAAS,IAAI,YAAe,AAC5B,CAAA,SAAW,CAAA,CAAK,AAChB,CAAA,GAAS,AAET,CAAA,UAAY,AAAA,CAAA,EAAA,EAAA,YAAA,AAAA,EAAa,IAAI,CAAC,IAAI,CAAE,AAEpC,YAAW,sBAAX,CACE,MAAO,CAAC,CAAE,KAAM,SAAS,EAAG,AAC9B,CAEA,aAAA,CACE,KAAK,GACL,IAAI,CAAC,IAAI,CAAC,KAAK,EACjB,CAEA,QACE,CAAwB,CACxB,CAA0B,CAC1B,CAAwC,CAH1C,CAKE,IAAM,EAAQ,CAAM,CAAC,EAAE,C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","sources":["<anon>","packages/base-nodes/src/Spectroscope/worklet.ts","node_modules/.pnpm/fft-js@0.0.12/node_modules/fft-js/index.js","node_modules/.pnpm/fft-js@0.0.12/node_modules/fft-js/src/fft.js","node_modules/.pnpm/fft-js@0.0.12/node_modules/fft-js/src/complex.js","node_modules/.pnpm/fft-js@0.0.12/node_modules/fft-js/src/fftutil.js","node_modules/.pnpm/bit-twiddle@1.0.2/node_modules/bit-twiddle/twiddle.js","node_modules/.pnpm/fft-js@0.0.12/node_modules/fft-js/src/ifft.js","node_modules/.pnpm/fft-js@0.0.12/node_modules/fft-js/src/dft.js","node_modules/.pnpm/fft-js@0.0.12/node_modules/fft-js/src/idft.js","packages/base-nodes/src/lib/useBroadcast.ts","node_modules/.pnpm/@parcel+transformer-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/transformer-js/src/esmodule-helpers.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"gIdr9\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"SpectroscopeProcessor\", ()=>SpectroscopeProcessor);\nvar _fftJs = require(\"fft-js\");\nvar _useBroadcast = require(\"../lib/useBroadcast\");\nconst DEFAULT_FFT_SIZE = 2048;\nclass SpectroscopeProcessor extends AudioWorkletProcessor {\n    sampleIndex = 0;\n    buffer = new Float32Array();\n    isActive = true;\n    fft;\n    broadcast = (0, _useBroadcast.useBroadcast)(this.port);\n    static get parameterDescriptors() {\n        return [\n            {\n                name: \"fftSize\"\n            }\n        ];\n    }\n    constructor(){\n        super();\n        this.port.start();\n    }\n    process(inputs, _outputs, parameters) {\n        const input = inputs[0][0];\n        const fftSize = parameters.fftSize[0];\n        const analysisWindowSize = fftSize <= 0 ? DEFAULT_FFT_SIZE : fftSize;\n        if (this.buffer.length !== analysisWindowSize) this.buffer = new Float32Array(analysisWindowSize);\n        if (!input && this.isActive) {\n            this.broadcast({\n                phasors: [],\n                magnitudes: new Uint8Array(),\n                frequencies: new Uint8Array()\n            });\n            this.isActive = false;\n        }\n        if (input && !this.isActive) this.isActive = true;\n        for(let i = 0; i < input?.length; i += 1){\n            this.buffer[this.sampleIndex] = input[i];\n            this.sampleIndex += 1;\n            if (this.sampleIndex >= analysisWindowSize) {\n                const phasors = (0, _fftJs.fft)(this.buffer);\n                const frequencies = new Uint8Array((0, _fftJs.util).fftFreq(phasors, sampleRate));\n                const magnitudes = new Uint8Array((0, _fftJs.util).fftMag(phasors));\n                this.broadcast({\n                    phasors,\n                    frequencies,\n                    magnitudes\n                });\n                this.sampleIndex = 0;\n            }\n        }\n        return true;\n    }\n}\ntry {\n    //@ts-ignore\n    registerProcessor(\"spectroscope-processor\", SpectroscopeProcessor);\n} catch (e) {}\n\n},{\"fft-js\":\"gMcVp\",\"../lib/useBroadcast\":\"eLhYv\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"4w0m1\"}],\"gMcVp\":[function(require,module,exports) {\n/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/ module.exports = {\n    fft: require(\"ebbccf2ef5a80fcc\").fft,\n    ifft: require(\"957950cb83760b6\").ifft,\n    fftInPlace: require(\"ebbccf2ef5a80fcc\").fftInPlace,\n    util: require(\"a47e5c75e4adf441\"),\n    dft: require(\"1f5b4c8889d3dbf1\"),\n    idft: require(\"acffb7efdf9d50aa\")\n};\n\n},{\"ebbccf2ef5a80fcc\":\"g2hPi\",\"957950cb83760b6\":\"2KXrW\",\"a47e5c75e4adf441\":\"42zmU\",\"1f5b4c8889d3dbf1\":\"7FrDi\",\"acffb7efdf9d50aa\":\"gN2QK\"}],\"g2hPi\":[function(require,module,exports) {\n/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/ //------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// To get high performace would require transforming\n// the recursive calls into a loop and then loop\n// unrolling. All of this is best accomplished\n// in C or assembly.\n//-------------------------------------------------\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar complex = require(\"b0c5eb085299c3ae\"), fftUtil = require(\"873e464629e8c570\"), twiddle = require(\"79cd644a8ceea180\");\nmodule.exports = {\n    //-------------------------------------------------\n    // Calculate FFT for vector where vector.length\n    // is assumed to be a power of 2.\n    //-------------------------------------------------\n    fft: function fft(vector) {\n        var X = [], N = vector.length;\n        // Base case is X = x + 0i since our input is assumed to be real only.\n        if (N == 1) {\n            if (Array.isArray(vector[0])) return [\n                [\n                    vector[0][0],\n                    vector[0][1]\n                ]\n            ];\n            else return [\n                [\n                    vector[0],\n                    0\n                ]\n            ];\n        }\n        // Recurse: all even samples\n        var X_evens = fft(vector.filter(even)), // Recurse: all odd samples\n        X_odds = fft(vector.filter(odd));\n        // Now, perform N/2 operations!\n        for(var k = 0; k < N / 2; k++){\n            // t is a complex number!\n            var t = X_evens[k], e = complex.multiply(fftUtil.exponent(k, N), X_odds[k]);\n            X[k] = complex.add(t, e);\n            X[k + N / 2] = complex.subtract(t, e);\n        }\n        function even(__, ix) {\n            return ix % 2 == 0;\n        }\n        function odd(__, ix) {\n            return ix % 2 == 1;\n        }\n        return X;\n    },\n    //-------------------------------------------------\n    // Calculate FFT for vector where vector.length\n    // is assumed to be a power of 2.  This is the in-\n    // place implementation, to avoid the memory\n    // footprint used by recursion.\n    //-------------------------------------------------\n    fftInPlace: function(vector) {\n        var N = vector.length;\n        var trailingZeros = twiddle.countTrailingZeros(N); //Once reversed, this will be leading zeros\n        // Reverse bits\n        for(var k = 0; k < N; k++){\n            var p = twiddle.reverse(k) >>> twiddle.INT_BITS - trailingZeros;\n            if (p > k) {\n                var complexTemp = [\n                    vector[k],\n                    0\n                ];\n                vector[k] = vector[p];\n                vector[p] = complexTemp;\n            } else vector[p] = [\n                vector[p],\n                0\n            ];\n        }\n        //Do the DIT now in-place\n        for(var len = 2; len <= N; len += len)for(var i = 0; i < len / 2; i++){\n            var w = fftUtil.exponent(i, len);\n            for(var j = 0; j < N / len; j++){\n                var t = complex.multiply(w, vector[j * len + i + len / 2]);\n                vector[j * len + i + len / 2] = complex.subtract(vector[j * len + i], t);\n                vector[j * len + i] = complex.add(vector[j * len + i], t);\n            }\n        }\n    }\n};\n\n},{\"b0c5eb085299c3ae\":\"5HOA1\",\"873e464629e8c570\":\"42zmU\",\"79cd644a8ceea180\":\"bUcd2\"}],\"5HOA1\":[function(require,module,exports) {\n//-------------------------------------------------\n// Add two complex numbers\n//-------------------------------------------------\nvar complexAdd = function(a, b) {\n    return [\n        a[0] + b[0],\n        a[1] + b[1]\n    ];\n};\n//-------------------------------------------------\n// Subtract two complex numbers\n//-------------------------------------------------\nvar complexSubtract = function(a, b) {\n    return [\n        a[0] - b[0],\n        a[1] - b[1]\n    ];\n};\n//-------------------------------------------------\n// Multiply two complex numbers\n//\n// (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n//-------------------------------------------------\nvar complexMultiply = function(a, b) {\n    return [\n        a[0] * b[0] - a[1] * b[1],\n        a[0] * b[1] + a[1] * b[0]\n    ];\n};\n//-------------------------------------------------\n// Calculate |a + bi|\n//\n// sqrt(a*a + b*b)\n//-------------------------------------------------\nvar complexMagnitude = function(c) {\n    return Math.sqrt(c[0] * c[0] + c[1] * c[1]);\n};\n//-------------------------------------------------\n// Exports\n//-------------------------------------------------\nmodule.exports = {\n    add: complexAdd,\n    subtract: complexSubtract,\n    multiply: complexMultiply,\n    magnitude: complexMagnitude\n};\n\n},{}],\"42zmU\":[function(require,module,exports) {\n/*===========================================================================*\\\n * Fast Fourier Transform Frequency/Magnitude passes\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/ //-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar complex = require(\"19a4857845fe0491\");\n//-------------------------------------------------\n// By Eulers Formula:\n//\n// e^(i*x) = cos(x) + i*sin(x)\n//\n// and in DFT:\n//\n// x = -2*PI*(k/N)\n//-------------------------------------------------\nvar mapExponent = {}, exponent = function(k, N) {\n    var x = -2 * Math.PI * (k / N);\n    mapExponent[N] = mapExponent[N] || {};\n    mapExponent[N][k] = mapExponent[N][k] || [\n        Math.cos(x),\n        Math.sin(x)\n    ]; // [Real, Imaginary]\n    return mapExponent[N][k];\n};\n//-------------------------------------------------\n// Calculate FFT Magnitude for complex numbers.\n//-------------------------------------------------\nvar fftMag = function(fftBins) {\n    var ret = fftBins.map(complex.magnitude);\n    return ret.slice(0, ret.length / 2);\n};\n//-------------------------------------------------\n// Calculate Frequency Bins\n// \n// Returns an array of the frequencies (in hertz) of\n// each FFT bin provided, assuming the sampleRate is\n// samples taken per second.\n//-------------------------------------------------\nvar fftFreq = function(fftBins, sampleRate) {\n    var stepFreq = sampleRate / fftBins.length;\n    var ret = fftBins.slice(0, fftBins.length / 2);\n    return ret.map(function(__, ix) {\n        return ix * stepFreq;\n    });\n};\n//-------------------------------------------------\n// Exports\n//-------------------------------------------------\nmodule.exports = {\n    fftMag: fftMag,\n    fftFreq: fftFreq,\n    exponent: exponent\n};\n\n},{\"19a4857845fe0491\":\"5HOA1\"}],\"bUcd2\":[function(require,module,exports) {\n/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */ \"use strict\";\n\"use restrict\";\n//Number of bits in an integer\nvar INT_BITS = 32;\n//Constants\nexports.INT_BITS = INT_BITS;\nexports.INT_MAX = 0x7fffffff;\nexports.INT_MIN = -1 << INT_BITS - 1;\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n    return (v > 0) - (v < 0);\n};\n//Computes absolute value of integer\nexports.abs = function(v) {\n    var mask = v >> INT_BITS - 1;\n    return (v ^ mask) - mask;\n};\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n    return y ^ (x ^ y) & -(x < y);\n};\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n    return x ^ (x ^ y) & -(x < y);\n};\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n    return !(v & v - 1) && !!v;\n};\n//Computes log base 2 of v\nexports.log2 = function(v) {\n    var r, shift;\n    r = (v > 0xFFFF) << 4;\n    v >>>= r;\n    shift = (v > 0xFF) << 3;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 0xF) << 2;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 0x3) << 1;\n    v >>>= shift;\n    r |= shift;\n    return r | v >> 1;\n};\n//Computes log base 10 of v\nexports.log10 = function(v) {\n    return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;\n};\n//Counts number of bits\nexports.popCount = function(v) {\n    v = v - (v >>> 1 & 0x55555555);\n    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);\n    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;\n};\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n    var c = 32;\n    v &= -v;\n    if (v) c--;\n    if (v & 0x0000FFFF) c -= 16;\n    if (v & 0x00FF00FF) c -= 8;\n    if (v & 0x0F0F0F0F) c -= 4;\n    if (v & 0x33333333) c -= 2;\n    if (v & 0x55555555) c -= 1;\n    return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n    v += v === 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n    return v + 1;\n};\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n    return v - (v >>> 1);\n};\n//Computes parity of word\nexports.parity = function(v) {\n    v ^= v >>> 16;\n    v ^= v >>> 8;\n    v ^= v >>> 4;\n    v &= 0xf;\n    return 0x6996 >>> v & 1;\n};\nvar REVERSE_TABLE = new Array(256);\n(function(tab) {\n    for(var i = 0; i < 256; ++i){\n        var v = i, r = i, s = 7;\n        for(v >>>= 1; v; v >>>= 1){\n            r <<= 1;\n            r |= v & 1;\n            --s;\n        }\n        tab[i] = r << s & 0xff;\n    }\n})(REVERSE_TABLE);\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n    return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];\n};\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n    x &= 0xFFFF;\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n    y &= 0xFFFF;\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n    return x | y << 1;\n};\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n    v = v >>> n & 0x55555555;\n    v = (v | v >>> 1) & 0x33333333;\n    v = (v | v >>> 2) & 0x0F0F0F0F;\n    v = (v | v >>> 4) & 0x00FF00FF;\n    v = (v | v >>> 16) & 0x000FFFF;\n    return v << 16 >> 16;\n};\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n    x &= 0x3FF;\n    x = (x | x << 16) & 4278190335;\n    x = (x | x << 8) & 251719695;\n    x = (x | x << 4) & 3272356035;\n    x = (x | x << 2) & 1227133513;\n    y &= 0x3FF;\n    y = (y | y << 16) & 4278190335;\n    y = (y | y << 8) & 251719695;\n    y = (y | y << 4) & 3272356035;\n    y = (y | y << 2) & 1227133513;\n    x |= y << 1;\n    z &= 0x3FF;\n    z = (z | z << 16) & 4278190335;\n    z = (z | z << 8) & 251719695;\n    z = (z | z << 4) & 3272356035;\n    z = (z | z << 2) & 1227133513;\n    return x | z << 2;\n};\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n    v = v >>> n & 1227133513;\n    v = (v | v >>> 2) & 3272356035;\n    v = (v | v >>> 4) & 251719695;\n    v = (v | v >>> 8) & 4278190335;\n    v = (v | v >>> 16) & 0x3FF;\n    return v << 22 >> 22;\n};\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n    var t = v | v - 1;\n    return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;\n};\n\n},{}],\"2KXrW\":[function(require,module,exports) {\n/*===========================================================================*\\\n * Inverse Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Maximilian Bügler. 2016\n *\n * Based on and using the code by\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/ //------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// To get high performace would require transforming\n// the recursive calls into a loop and then loop\n// unrolling. All of this is best accomplished\n// in C or assembly.\n//-------------------------------------------------\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar fft = require(\"1ce71890adda7bb5\").fft;\nmodule.exports = {\n    ifft: function ifft(signal) {\n        //Interchange real and imaginary parts\n        var csignal = [];\n        for(var i = 0; i < signal.length; i++)csignal[i] = [\n            signal[i][1],\n            signal[i][0]\n        ];\n        //Apply fft\n        var ps = fft(csignal);\n        //Interchange real and imaginary parts and normalize\n        var res = [];\n        for(var j = 0; j < ps.length; j++)res[j] = [\n            ps[j][1] / ps.length,\n            ps[j][0] / ps.length\n        ];\n        return res;\n    }\n};\n\n},{\"1ce71890adda7bb5\":\"g2hPi\"}],\"7FrDi\":[function(require,module,exports) {\n/*===========================================================================*\\\n * Discrete Fourier Transform (O(n^2) brute-force method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/ //------------------------------------------------\n// Note: this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n//------------------------------------------------\nvar complex = require(\"294f5dc81b29040e\");\nvar fftUtil = require(\"454c34fe95536381\");\n//-------------------------------------------------\n// Calculate brute-force O(n^2) DFT for vector.\n//-------------------------------------------------\nvar dft = function(vector) {\n    var X = [], N = vector.length;\n    for(var k = 0; k < N; k++){\n        X[k] = [\n            0,\n            0\n        ]; //Initialize to a 0-valued complex number.\n        for(var i = 0; i < N; i++){\n            var exp = fftUtil.exponent(k * i, N);\n            var term;\n            if (Array.isArray(vector[i])) term = complex.multiply(vector[i], exp) //If input vector contains complex numbers\n            ;\n            else term = complex.multiply([\n                vector[i],\n                0\n            ], exp); //Complex mult of the signal with the exponential term.  \n            X[k] = complex.add(X[k], term); //Complex summation of X[k] and exponential\n        }\n    }\n    return X;\n};\nmodule.exports = dft;\n\n},{\"294f5dc81b29040e\":\"5HOA1\",\"454c34fe95536381\":\"42zmU\"}],\"gN2QK\":[function(require,module,exports) {\n/*===========================================================================*\\\n * Inverse Discrete Fourier Transform (O(n^2) brute-force method)\n *\n * (c) Maximilian Bügler. 2016\n *\n * Based on and using the code by\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/ //------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n//-------------------------------------------------\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar dft = require(\"1a7eb63f8cdb9efd\");\nfunction idft(signal) {\n    //Interchange real and imaginary parts\n    var csignal = [];\n    for(var i = 0; i < signal.length; i++)csignal[i] = [\n        signal[i][1],\n        signal[i][0]\n    ];\n    //Apply dft\n    var ps = dft(csignal);\n    //Interchange real and imaginary parts and normalize\n    var res = [];\n    for(var j = 0; j < ps.length; j++)res[j] = [\n        ps[j][1] / ps.length,\n        ps[j][0] / ps.length\n    ];\n    return res;\n}\nmodule.exports = idft;\n\n},{\"1a7eb63f8cdb9efd\":\"7FrDi\"}],\"eLhYv\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"Events\", ()=>Events);\nparcelHelpers.export(exports, \"useBroadcast\", ()=>useBroadcast);\nparcelHelpers.export(exports, \"addBroadcastListener\", ()=>addBroadcastListener);\nparcelHelpers.export(exports, \"removeBroadcastListener\", ()=>removeBroadcastListener);\nvar Events;\n(function(Events) {\n    Events[\"ADD_LISTENER\"] = \"ADD_LISTENER\";\n    Events[\"REMOVE_LISTENER\"] = \"REMOVE_LISTENER\";\n})(Events || (Events = {}));\nconst DEFAULT_POOL_NAME = \"default\";\nconst useBroadcast = (port)=>{\n    const listeners = {\n        [DEFAULT_POOL_NAME]: []\n    };\n    port.addEventListener(\"message\", ({ data })=>{\n        if (data.name === \"ADD_LISTENER\") {\n            const poolName = data.poolName ?? DEFAULT_POOL_NAME;\n            if (!listeners[poolName]) listeners[poolName] = [];\n            listeners[poolName].push(data.port);\n        }\n        if (data.name === \"REMOVE_LISTENER\") {\n            const poolName = data.poolName ?? DEFAULT_POOL_NAME;\n            if (!listeners[poolName]) listeners[poolName] = [];\n            listeners[poolName].push(data.port);\n        }\n    });\n    return (data, index = DEFAULT_POOL_NAME)=>{\n        return listeners[index]?.forEach((listener)=>listener.postMessage(data));\n    };\n};\nconst addBroadcastListener = (broadcastPort, listenerPort, poolName)=>{\n    broadcastPort.postMessage({\n        name: \"ADD_LISTENER\",\n        port: listenerPort,\n        poolName\n    }, [\n        listenerPort\n    ]);\n};\nconst removeBroadcastListener = (broadcastPort, listenerPort, poolName)=>{\n    broadcastPort.postMessage({\n        name: \"REMOVE_LISTENER\",\n        // port: listenerPort,\n        poolName\n    }, []);\n};\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"4w0m1\"}],\"4w0m1\":[function(require,module,exports) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, \"__esModule\", {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\" || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}]},[\"gIdr9\"], \"gIdr9\", \"parcelRequirec6d8\")\n\n//# sourceMappingURL=worklet.f71f3d80.js.map\n","import { fft, util as fftUtil } from \"fft-js\";\nimport { useBroadcast } from \"../lib/useBroadcast\";\n\nconst DEFAULT_FFT_SIZE = 2048;\n\nexport class SpectroscopeProcessor extends AudioWorkletProcessor {\n  sampleIndex = 0;\n  buffer = new Float32Array();\n  isActive = true;\n  fft: any;\n\n  broadcast = useBroadcast(this.port);\n\n  static get parameterDescriptors() {\n    return [{ name: \"fftSize\" }];\n  }\n\n  constructor() {\n    super();\n    this.port.start();\n  }\n\n  process(\n    inputs: Float32Array[][],\n    _outputs: Float32Array[][],\n    parameters: Record<string, Float32Array>,\n  ) {\n    const input = inputs[0][0];\n\n    const fftSize = parameters.fftSize[0];\n    const analysisWindowSize = fftSize <= 0 ? DEFAULT_FFT_SIZE : fftSize;\n\n    if (this.buffer.length !== analysisWindowSize) {\n      this.buffer = new Float32Array(analysisWindowSize);\n    }\n\n    if (!input && this.isActive) {\n      this.broadcast({\n        phasors: [],\n        magnitudes: new Uint8Array(),\n        frequencies: new Uint8Array(),\n      });\n      this.isActive = false;\n    }\n    if (input && !this.isActive) {\n      this.isActive = true;\n    }\n\n    for (let i = 0; i < input?.length; i += 1) {\n      this.buffer[this.sampleIndex] = input[i];\n      this.sampleIndex += 1;\n\n      if (this.sampleIndex >= analysisWindowSize) {\n        const phasors: Array<[number, number]> = fft(this.buffer);\n        const frequencies = new Uint8Array(\n          fftUtil.fftFreq(phasors, sampleRate),\n        );\n        const magnitudes = new Uint8Array(fftUtil.fftMag(phasors));\n        this.broadcast({ phasors, frequencies, magnitudes });\n        this.sampleIndex = 0;\n      }\n    }\n\n    return true;\n  }\n}\n\ntry {\n  //@ts-ignore\n  registerProcessor(\"spectroscope-processor\", SpectroscopeProcessor);\n} catch (e) {}\n","/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\nmodule.exports = {\n    fft: require('./src/fft').fft,\n    ifft: require('./src/ifft').ifft,\n    fftInPlace: require('./src/fft').fftInPlace,\n    util: require('./src/fftutil'),\n    dft: require('./src/dft'),\n    idft: require('./src/idft')\n};\n","/*===========================================================================*\\\n * Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// To get high performace would require transforming\n// the recursive calls into a loop and then loop\n// unrolling. All of this is best accomplished\n// in C or assembly.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar complex = require('./complex'),\n    fftUtil = require('./fftutil'),\n    twiddle = require('bit-twiddle');\n\nmodule.exports = {\n  //-------------------------------------------------\n  // Calculate FFT for vector where vector.length\n  // is assumed to be a power of 2.\n  //-------------------------------------------------\n  fft: function fft(vector) {\n    var X = [],\n        N = vector.length;\n\n    // Base case is X = x + 0i since our input is assumed to be real only.\n    if (N == 1) {\n      if (Array.isArray(vector[0])) //If input vector contains complex numbers\n        return [[vector[0][0], vector[0][1]]];      \n      else\n        return [[vector[0], 0]];\n    }\n\n    // Recurse: all even samples\n    var X_evens = fft(vector.filter(even)),\n\n        // Recurse: all odd samples\n        X_odds  = fft(vector.filter(odd));\n\n    // Now, perform N/2 operations!\n    for (var k = 0; k < N / 2; k++) {\n      // t is a complex number!\n      var t = X_evens[k],\n          e = complex.multiply(fftUtil.exponent(k, N), X_odds[k]);\n\n      X[k] = complex.add(t, e);\n      X[k + (N / 2)] = complex.subtract(t, e);\n    }\n\n    function even(__, ix) {\n      return ix % 2 == 0;\n    }\n\n    function odd(__, ix) {\n      return ix % 2 == 1;\n    }\n\n    return X;\n  },\n  //-------------------------------------------------\n  // Calculate FFT for vector where vector.length\n  // is assumed to be a power of 2.  This is the in-\n  // place implementation, to avoid the memory\n  // footprint used by recursion.\n  //-------------------------------------------------\n  fftInPlace: function(vector) {\n    var N = vector.length;\n\n    var trailingZeros = twiddle.countTrailingZeros(N); //Once reversed, this will be leading zeros\n\n    // Reverse bits\n    for (var k = 0; k < N; k++) {\n      var p = twiddle.reverse(k) >>> (twiddle.INT_BITS - trailingZeros);\n      if (p > k) {\n        var complexTemp = [vector[k], 0];\n        vector[k] = vector[p];\n        vector[p] = complexTemp;\n      } else {\n        vector[p] = [vector[p], 0];\n      }\n    }\n\n    //Do the DIT now in-place\n    for (var len = 2; len <= N; len += len) {\n      for (var i = 0; i < len / 2; i++) {\n        var w = fftUtil.exponent(i, len);\n        for (var j = 0; j < N / len; j++) {\n          var t = complex.multiply(w, vector[j * len + i + len / 2]);\n          vector[j * len + i + len / 2] = complex.subtract(vector[j * len + i], t);\n          vector[j * len + i] = complex.add(vector[j * len + i], t);\n        }\n      }\n    }\n  }\n};\n","//-------------------------------------------------\n// Add two complex numbers\n//-------------------------------------------------\nvar complexAdd = function (a, b)\n{\n    return [a[0] + b[0], a[1] + b[1]];\n};\n\n//-------------------------------------------------\n// Subtract two complex numbers\n//-------------------------------------------------\nvar complexSubtract = function (a, b)\n{\n    return [a[0] - b[0], a[1] - b[1]];\n};\n\n//-------------------------------------------------\n// Multiply two complex numbers\n//\n// (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n//-------------------------------------------------\nvar complexMultiply = function (a, b) \n{\n    return [(a[0] * b[0] - a[1] * b[1]), \n            (a[0] * b[1] + a[1] * b[0])];\n};\n\n//-------------------------------------------------\n// Calculate |a + bi|\n//\n// sqrt(a*a + b*b)\n//-------------------------------------------------\nvar complexMagnitude = function (c) \n{\n    return Math.sqrt(c[0]*c[0] + c[1]*c[1]); \n};\n\n//-------------------------------------------------\n// Exports\n//-------------------------------------------------\nmodule.exports = {\n    add: complexAdd,\n    subtract: complexSubtract,\n    multiply: complexMultiply,\n    magnitude: complexMagnitude\n};\n","/*===========================================================================*\\\n * Fast Fourier Transform Frequency/Magnitude passes\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar complex = require('./complex');\n\n\n//-------------------------------------------------\n// By Eulers Formula:\n//\n// e^(i*x) = cos(x) + i*sin(x)\n//\n// and in DFT:\n//\n// x = -2*PI*(k/N)\n//-------------------------------------------------\nvar mapExponent = {},\n    exponent = function (k, N) {\n      var x = -2 * Math.PI * (k / N);\n\n      mapExponent[N] = mapExponent[N] || {};\n      mapExponent[N][k] = mapExponent[N][k] || [Math.cos(x), Math.sin(x)];// [Real, Imaginary]\n\n      return mapExponent[N][k];\n};\n\n//-------------------------------------------------\n// Calculate FFT Magnitude for complex numbers.\n//-------------------------------------------------\nvar fftMag = function (fftBins) {\n    var ret = fftBins.map(complex.magnitude);\n    return ret.slice(0, ret.length / 2);\n};\n\n//-------------------------------------------------\n// Calculate Frequency Bins\n// \n// Returns an array of the frequencies (in hertz) of\n// each FFT bin provided, assuming the sampleRate is\n// samples taken per second.\n//-------------------------------------------------\nvar fftFreq = function (fftBins, sampleRate) {\n    var stepFreq = sampleRate / (fftBins.length);\n    var ret = fftBins.slice(0, fftBins.length / 2);\n\n    return ret.map(function (__, ix) {\n        return ix * stepFreq;\n    });\n};\n\n//-------------------------------------------------\n// Exports\n//-------------------------------------------------\nmodule.exports = {\n    fftMag: fftMag,\n    fftFreq: fftFreq,\n    exponent: exponent\n};\n","/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n\"use strict\"; \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n","/*===========================================================================*\\\n * Inverse Fast Fourier Transform (Cooley-Tukey Method)\n *\n * (c) Maximilian Bügler. 2016\n *\n * Based on and using the code by\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n// To get high performace would require transforming\n// the recursive calls into a loop and then loop\n// unrolling. All of this is best accomplished\n// in C or assembly.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\n\nvar fft = require('./fft').fft;\n\n\nmodule.exports = {\n    ifft: function ifft(signal){\n        //Interchange real and imaginary parts\n        var csignal=[];\n        for(var i=0; i<signal.length; i++){\n            csignal[i]=[signal[i][1], signal[i][0]];\n        }\n    \n        //Apply fft\n        var ps=fft(csignal);\n        \n        //Interchange real and imaginary parts and normalize\n        var res=[];\n        for(var j=0; j<ps.length; j++){\n            res[j]=[ps[j][1]/ps.length, ps[j][0]/ps.length];\n        }\n        return res;\n    }\n};\n","/*===========================================================================*\\\n * Discrete Fourier Transform (O(n^2) brute-force method)\n *\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n//------------------------------------------------\nvar complex = require('./complex');\nvar fftUtil = require('./fftutil');\n\n//-------------------------------------------------\n// Calculate brute-force O(n^2) DFT for vector.\n//-------------------------------------------------\nvar dft = function(vector) {\n  var X = [],\n      N = vector.length;\n\n  for (var k = 0; k < N; k++) {\n    X[k] = [0, 0]; //Initialize to a 0-valued complex number.\n\n    for (var i = 0; i < N; i++) {\n      var exp = fftUtil.exponent(k * i, N);\n      var term;\n      if (Array.isArray(vector[i]))\n        term = complex.multiply(vector[i], exp)//If input vector contains complex numbers\n      else\n        term = complex.multiply([vector[i], 0], exp);//Complex mult of the signal with the exponential term.  \n      X[k] = complex.add(X[k], term); //Complex summation of X[k] and exponential\n    }\n  }\n\n  return X;\n};\n\nmodule.exports = dft;","/*===========================================================================*\\\n * Inverse Discrete Fourier Transform (O(n^2) brute-force method)\n *\n * (c) Maximilian Bügler. 2016\n *\n * Based on and using the code by\n * (c) Vail Systems. Joshua Jung and Ben Bryan. 2015\n *\n * This code is not designed to be highly optimized but as an educational\n * tool to understand the Fast Fourier Transform.\n\\*===========================================================================*/\n\n//------------------------------------------------\n// Note: Some of this code is not optimized and is\n// primarily designed as an educational and testing\n// tool.\n//-------------------------------------------------\n\n//-------------------------------------------------\n// The following code assumes a complex number is\n// an array: [real, imaginary]\n//-------------------------------------------------\nvar dft = require('./dft');\n\nfunction idft(signal) {\n    //Interchange real and imaginary parts\n    var csignal = [];\n    for (var i = 0; i < signal.length; i++) {\n        csignal[i] = [signal[i][1], signal[i][0]];\n    }\n\n    //Apply dft\n    var ps = dft(csignal);\n\n    //Interchange real and imaginary parts and normalize\n    var res = [];\n    for (var j = 0; j < ps.length; j++) {\n        res[j] = [ps[j][1] / ps.length, ps[j][0] / ps.length];\n    }\n    return res;\n}\n\nmodule.exports = idft;","type PoolName = string | number;\n\ntype Broadcast = <T = unknown>(data: T, poolName?: PoolName) => void;\n\nexport enum Events {\n  ADD_LISTENER = \"ADD_LISTENER\",\n  REMOVE_LISTENER = \"REMOVE_LISTENER\",\n}\n\ninterface EventListener {}\n\ninterface AddListenerEvent {\n  name: \"ADD_LISTENER\";\n  port: MessagePort;\n  poolName?: string | number;\n}\n\ninterface RemoveListenerEvent {\n  name: \"REMOVE_LISTENER\";\n  port: MessagePort;\n  poolName?: string | number;\n}\n\ntype UseBroadcastEvent = AddListenerEvent | RemoveListenerEvent;\n\nconst DEFAULT_POOL_NAME = \"default\";\n\n/**\n * hook for usage inside a worklet\n * */\nexport const useBroadcast = (port: MessagePort): Broadcast => {\n  const listeners: Record<PoolName, Array<MessagePort>> = {\n    [DEFAULT_POOL_NAME]: [],\n  };\n  port.addEventListener(\n    \"message\",\n    ({ data }: MessageEvent<UseBroadcastEvent>) => {\n      if (data.name === \"ADD_LISTENER\") {\n        const poolName = data.poolName ?? DEFAULT_POOL_NAME;\n        if (!listeners[poolName]) {\n          listeners[poolName] = [];\n        }\n        listeners[poolName].push(data.port);\n      }\n      if (data.name === \"REMOVE_LISTENER\") {\n        const poolName = data.poolName ?? DEFAULT_POOL_NAME;\n        if (!listeners[poolName]) {\n          listeners[poolName] = [];\n        }\n        listeners[poolName].push(data.port);\n      }\n    },\n  );\n\n  return (data, index = DEFAULT_POOL_NAME) => {\n    return listeners[index]?.forEach((listener) => listener.postMessage(data));\n  };\n};\n\n/**\n * helpers for usage outside or audio worklet\n * */\nexport const addBroadcastListener = (\n  broadcastPort: MessagePort,\n  listenerPort: MessagePort,\n  poolName?: PoolName,\n) => {\n  broadcastPort.postMessage(\n    {\n      name: \"ADD_LISTENER\",\n      port: listenerPort,\n      poolName,\n    },\n    [listenerPort],\n  );\n};\n\nexport const removeBroadcastListener = (\n  broadcastPort: MessagePort,\n  listenerPort: MessagePort,\n  poolName?: PoolName,\n) => {\n  broadcastPort.postMessage(\n    {\n      name: \"REMOVE_LISTENER\",\n      // port: listenerPort,\n      poolName,\n    },\n    [],\n  );\n};\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","parcelHelpers","defineInteropFlag","export","SpectroscopeProcessor","_fftJs","_useBroadcast","AudioWorkletProcessor","sampleIndex","buffer","Float32Array","isActive","fft","broadcast","useBroadcast","port","parameterDescriptors","constructor","start","process","inputs","_outputs","parameters","input","fftSize","analysisWindowSize","phasors","magnitudes","Uint8Array","frequencies","util","fftFreq","sampleRate","fftMag","registerProcessor","e","ifft","fftInPlace","dft","idft","complex","fftUtil","twiddle","vector","X","N","Array","isArray","X_evens","filter","__","ix","X_odds","k","t","multiply","exponent","add","subtract","trailingZeros","countTrailingZeros","p","reverse","INT_BITS","complexTemp","len","w","j","a","b","magnitude","c","Math","sqrt","mapExponent","fftBins","ret","map","slice","stepFreq","PI","cos","sin","v","INT_MAX","INT_MIN","sign","abs","mask","min","y","max","isPow2","log2","r","shift","log10","popCount","nextPow2","prevPow2","parity","REVERSE_TABLE","tab","s","interleave2","deinterleave2","n","interleave3","z","deinterleave3","nextCombination","signal","csignal","ps","term","exp","Events","addBroadcastListener","removeBroadcastListener","DEFAULT_POOL_NAME","listeners","addEventListener","data","poolName","push","index","forEach","listener","postMessage","broadcastPort","listenerPort","interopDefault","__esModule","default","value","exportAll","source","dest","keys","key","prototype","hasOwnProperty","enumerable","destName"],"version":3,"file":"worklet.f71f3d80.js.map"}